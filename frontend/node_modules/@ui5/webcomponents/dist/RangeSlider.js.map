{"version":3,"file":"RangeSlider.js","sourceRoot":"","sources":["../src/RangeSlider.ts"],"names":[],"mappings":"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","sourcesContent":["import customElement from \"@ui5/webcomponents-base/dist/decorators/customElement.js\";\nimport property from \"@ui5/webcomponents-base/dist/decorators/property.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport type I18nBundle from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport {\n\tisEscape,\n\tisHome,\n\tisEnd,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport Icon from \"./Icon.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n// Texts\nimport {\n\tRANGE_SLIDER_ARIA_DESCRIPTION,\n\tRANGE_SLIDER_START_HANDLE_DESCRIPTION,\n\tRANGE_SLIDER_END_HANDLE_DESCRIPTION,\n} from \"./generated/i18n/i18n-defaults.js\";\n\n// Styles\nimport rangeSliderStyles from \"./generated/themes/RangeSlider.css.js\";\n\ntype AriaHandlesText = {\n\tstartHandleText?: string,\n\tendHandleText?: string,\n}\n\ntype AffectedValue = \"startValue\" | \"endValue\";\n\n/**\n * @class\n *\n * ### Overview\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * ### Structure\n * The most important properties of the Range Slider are:\n *\n * - min - The minimum value of the slider range.\n * - max - The maximum value of the slider range.\n * - value - The current value of the slider.\n * - step - Determines the increments in which the slider will move.\n * - showTooltip - Determines if a tooltip should be displayed above the handle.\n * - showTickmarks - Displays a visual divider between the step values.\n * - labelInterval - Labels some or all of the tickmarks with their values.\n *\n * #### Notes:\n *\n * - The right and left handle can be moved individually and their positions could therefore switch.\n * - The entire range can be moved along the interval.\n *\n * ### Usage\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * ### Responsive Behavior\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * ### Keyboard Handling\n *\n * - `Left or Down Arrow` - Moves a component's handle or the entire selection one step to the left;\n * - `Right or Up Arrow` - Moves a component's handle or the entire selection one step to the right;\n * - `Left or Down Arrow + Ctrl/Cmd` - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;\n * - `Right or Up Arrow + Ctrl/Cmd` - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;\n * - `Plus` - Same as `Right or Up Arrow`;\n * - `Minus` - Same as `Left or Down Arrow`;\n * - `Home` - Moves the entire selection or the selected handle to the beginning of the component's range;\n * - `End` - Moves the entire selection or the selected handle to the end of the component's range;\n * - `Page Up` - Same as `Right or Up Arrow + Ctrl/Cmd`;\n * - `Page Down` - Same as `Left or Down Arrow + Ctrl/Cmd`;\n * - `Escape` - Resets the `startValue` and `endValue` properties to the values prior the component focusing;\n *\n * ### ES6 Module Import\n *\n * `import \"@ui5/webcomponents/dist/RangeSlider.js\";`\n * @constructor\n * @extends SliderBase\n * @since 1.0.0-rc.11\n * @public\n * @csspart progress-container - Used to style the progress container, the horizontal bar that visually represents the range between the minimum and maximum values, of the `ui5-range-slider`.\n * @csspart progress-bar - Used to style the progress bar, which shows the progress of the `ui5-range-slider`.\n * @csspart handle - Used to style the handles of the `ui5-range-slider`.\n */\n@customElement({\n\ttag: \"ui5-range-slider\",\n\tlanguageAware: true,\n\ttemplate: RangeSliderTemplate,\n\tdependencies: [Icon],\n\tstyles: [SliderBase.styles, rangeSliderStyles],\n})\nclass RangeSlider extends SliderBase {\n\t/**\n\t * Defines start point of a selection - position of a first handle on the slider.\n\t * @default 0\n\t * @formEvents change input\n\t * @formProperty\n\t * @public\n\t */\n\t@property({ validator: Float, defaultValue: 0 })\n\tstartValue!: number;\n\n\t/**\n\t * Defines end point of a selection - position of a second handle on the slider.\n\t * @default 100\n\t * @formEvents change input\n\t * @formProperty\n\t * @public\n\t */\n\t@property({ validator: Float, defaultValue: 100 })\n\tendValue!: number;\n\n\t@property({ type: Boolean })\n\trangePressed!: boolean;\n\n\t_startValueInitial?: number;\n\t_endValueInitial?: number;\n\t_valueAffected?: AffectedValue;\n\t_isPressInCurrentRange = false;\n\t_handeIsPressed = false;\n\t_initialPageXPosition?: number;\n\t_startValueAtBeginningOfAction?: number;\n\t_endValueAtBeginningOfAction?: number;\n\t_initialStartHandlePageX?: number;\n\t_firstHandlePositionFromStart?: number;\n\t_secondHandlePositionFromStart?: number;\n\t_selectedRange?: number;\n\t_reversedValues = false;\n\n\tstatic i18nBundle: I18nBundle;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.startValue = undefined;\n\t\tthis._stateStorage.endValue = undefined;\n\t}\n\n\tget tooltipStartValue() {\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.startValue.toFixed(stepPrecision);\n\t}\n\n\tget tooltipEndValue() {\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.endValue.toFixed(stepPrecision);\n\t}\n\n\tget _ariaDisabled() {\n\t\treturn this.disabled || undefined;\n\t}\n\n\tget _ariaLabelledByText() {\n\t\treturn RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n\t}\n\n\tget _ariaHandlesText() {\n\t\tconst isRTL = this.effectiveDir === \"rtl\";\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst ariaHandlesText: AriaHandlesText = {};\n\n\t\tif ((isRTL && !isReversed) || (!isRTL && isReversed)) {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t} else {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t}\n\n\t\treturn ariaHandlesText;\n\t}\n\n\tget _ariaValueNow() {\n\t\treturn Math.abs(this.endValue - this.startValue);\n\t}\n\n\t/**\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programmatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (this.startValue > this.endValue) {\n\t\t\tconst affectedValue = this._valueAffected === \"startValue\" ? \"endValue\" : \"startValue\";\n\n\t\t\tthis._swapValues();\n\t\t\tthis._setAffectedValue(affectedValue);\n\t\t\tthis.update(affectedValue, this.startValue, this.endValue);\n\t\t}\n\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState();\n\t\tthis._updateHandlesAndRange(0);\n\t}\n\n\tsyncUIAndState() {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", \"startValue\", \"endValue\")) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programmatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tconst normalizedStartValue = SliderBase.clipValue(this.startValue, this._effectiveMin, this._effectiveMax);\n\t\t\tthis.startValue = normalizedStartValue;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"startValue\");\n\t\t\tthis.storePropertyState(\"startValue\");\n\n\t\t\tconst normalizedEndValue = SliderBase.clipValue(this.endValue, this._effectiveMin, this._effectiveMax);\n\t\t\tthis.endValue = normalizedEndValue;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"endValue\");\n\t\t\tthis.storePropertyState(\"endValue\");\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t_onfocusin() {\n\t\t// If this is the initial focusin of the component save its initial\n\t\t// value properties so they could be restored on ESC key press\n\t\tif (!this._endValueInitial) {\n\t\t\tthis._startValueInitial = this.startValue;\n\t\t\tthis._endValueInitial = this.endValue;\n\t\t}\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Handles focus out event of the focusable components inner elements.\n\t * Prevent focusout when the focus is getting initially set within the slider before the\n\t * slider customElement itself is finished focusing.\n\t *\n\t * Prevents the focus from leaving the Range Slider when the focus is managed between\n\t * its inner elements in result of user interactions.\n\t *\n\t * Resets the stored Range Slider's initial values saved when it was first focused\n\t * @private\n\t */\n\t_onfocusout() {\n\t\tif (this._isFocusing()) {\n\t\t\tthis._preventFocusOut();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._setAffectedValue(undefined);\n\t\tthis._startValueInitial = undefined;\n\t\tthis._endValueInitial = undefined;\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t* Handles keyup logic. If one of the handles came across the other\n\t* swap the start and end values. Reset the affected value by the finished\n\t* user interaction.\n\t* @private\n\t*/\n\t_onkeyup() {\n\t\tsuper._onkeyup();\n\t\tthis._setAffectedValue(undefined);\n\n\t\tif (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._startValueAtBeginningOfAction = undefined;\n\t\tthis._endValueAtBeginningOfAction = undefined;\n\t}\n\n\t_handleActionKeyPress(e: KeyboardEvent) {\n\t\tthis._startValueAtBeginningOfAction = this.startValue;\n\t\tthis._endValueAtBeginningOfAction = this.endValue;\n\n\t\tif (isEscape(e)) {\n\t\t\tthis.update(undefined, this._startValueInitial, this._endValueInitial);\n\t\t\treturn;\n\t\t}\n\n\t\t// Set the target of the interaction based on the focused inner element\n\t\tthis._setAffectedValueByFocusedElement();\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst affectedValue = this._valueAffected!;\n\n\t\t// If home/end key is pressed and no single handle is focused the active element\n\t\t// is the range selection - update both start and end values. Otherwise, if 'home'\n\t\t// is pressed the 'startValue'will be used for the start-handle offset calculation,\n\t\t// if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n\t\tif ((isEnd(e) || isHome(e)) && !affectedValue) {\n\t\t\tthis._homeEndForSelectedRange(e, isHome(e) ? \"startValue\" : \"endValue\", min, max);\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate how much the value should be increased/decreased based on the action key\n\t\tconst newValueOffset = this._handleActionKeyPressBase(e, affectedValue);\n\n\t\tif (!newValueOffset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update a single value if one of the handles is focused or the range if not already at min or max\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tif (affectedValue && !this._isPressInCurrentRange) {\n\t\t\tconst propValue = this[affectedValue as keyof RangeSlider] as number;\n\t\t\tconst newValue = ctor.clipValue(newValueOffset + propValue, min, max);\n\t\t\tthis.update(affectedValue, newValue, undefined);\n\t\t} else if ((newValueOffset < 0 && this.startValue > min) || (newValueOffset > 0 && this.endValue < max)) {\n\t\t\tconst newStartValue = ctor.clipValue(newValueOffset + this.startValue, min, max);\n\t\t\tconst newEndValue = ctor.clipValue(newValueOffset + this.endValue, min, max);\n\t\t\tthis.update(affectedValue, newStartValue, newEndValue);\n\t\t}\n\t}\n\n\t/**\n\t * Determines affected value (start/end) depending on the currently\n\t * active inner element within the Range Slider - used in the keyboard handling.\n\t * @private\n\t */\n\t_setAffectedValueByFocusedElement() {\n\t\tif (this.shadowRoot!.activeElement === this._startHandle) {\n\t\t\tthis._setAffectedValue(\"startValue\");\n\t\t}\n\n\t\tif (this.shadowRoot!.activeElement === this._endHandle) {\n\t\t\tthis._setAffectedValue(\"endValue\");\n\t\t}\n\n\t\tif (this.shadowRoot!.activeElement === this._progressBar) {\n\t\t\tthis._setAffectedValue(undefined);\n\t\t}\n\n\t\tthis._setIsPressInCurrentRange(!this._valueAffected);\n\t}\n\n\t/**\n\t * Calculates the start and end values when the 'Home\" or 'End' keys\n\t * are pressed on the selected range bar.\n\t * @private\n\t */\n\t_homeEndForSelectedRange(e: KeyboardEvent, affectedValue: string, min: number, max: number) {\n\t\tconst newValueOffset = this._handleActionKeyPressBase(e, affectedValue);\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst newStartValue = ctor.clipValue(newValueOffset + this.startValue, min, max);\n\t\tconst newEndValue = ctor.clipValue(newValueOffset + this.endValue, min, max);\n\n\t\tthis.update(undefined, newStartValue, newEndValue);\n\t}\n\n\t/**\n\t * Update values, stored inner state and the visual UI representation of the component.\n\t * If no specific type of value property is passed - the range is selected - update both handles,\n\t * otherwise update the handle corresponding to the affected by the user interacton value prop.\n\t * @private\n\t */\n\tupdate(affectedValue: string | undefined, startValue: number | undefined, endValue: number | undefined) {\n\t\tif (!affectedValue) {\n\t\t\tthis.startValue = startValue!;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"startValue\");\n\n\t\t\tthis.endValue = endValue!;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"endValue\");\n\t\t\tthis._updateHandlesAndRange(0);\n\t\t} else {\n\t\t\tconst newValue = endValue && affectedValue === \"endValue\" ? endValue : startValue;\n\t\t\tthis._updateHandlesAndRange(newValue || 0);\n\n\t\t\tif (affectedValue === \"startValue\") {\n\t\t\t\tthis.startValue = newValue!;\n\t\t\t\tthis.updateStateStorageAndFireInputEvent(\"startValue\");\n\t\t\t}\n\n\t\t\tif (affectedValue === \"endValue\") {\n\t\t\t\tthis.endValue = newValue!;\n\t\t\t\tthis.updateStateStorageAndFireInputEvent(\"endValue\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t * @private\n\t */\n\t_onmousedown(e: TouchEvent | MouseEvent) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the new value from the press position of the event\n\t\tconst newValue = this.handleDownBase(e);\n\n\t\t// Determine the rest of the needed details from the start of the interaction.\n\t\tthis._saveInteractionStartData(e, newValue);\n\n\t\tthis.rangePressed = this._isPressInCurrentRange;\n\n\t\t// Do not yet update the RangeSlider if press is in range or over a handle.\n\t\tif (this._isPressInCurrentRange || this._handeIsPressed) {\n\t\t\tthis._handeIsPressed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Update Slider UI and internal state\n\t\tthis.update(this._valueAffected, newValue, undefined);\n\t}\n\n\t/**\n\t * Determines and saves needed values from the start of the interaction:\n\t *\n\t * Is the value calculated is within the currently selected range;\n\t * Initial pageX position of the start handle affected by the interaction;\n\t * Initial pageX value of the pressed postion;\n\t * Affected value property by the action;\n\t * @private\n\t */\n\t_saveInteractionStartData(e: TouchEvent | MouseEvent, newValue: number) {\n\t\tconst progressBarDom = this.shadowRoot!.querySelector(\".ui5-slider-progress\")!.getBoundingClientRect();\n\n\t\t// Save the state of the value properties on the start of the interaction\n\t\tthis._startValueAtBeginningOfAction = this.startValue;\n\t\tthis._endValueAtBeginningOfAction = this.endValue;\n\n\t\t// Save the initial press point coordinates (position)\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tthis._initialPageXPosition = ctor.getPageXValueFromEvent(e);\n\t\t// Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\t\tthis._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\t\t// Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\t\tthis._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n\t}\n\n\t/**\n\t * Called when the user moves the slider\n\t * @private\n\t */\n\t_handleMove(e: TouchEvent | MouseEvent) {\n\t\te.preventDefault();\n\n\t\t// If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update UI and state when dragging a single Range Slider handle\n\t\tif (!this._isPressInCurrentRange) {\n\t\t\tthis._updateValueOnHandleDrag(e);\n\t\t\treturn;\n\t\t}\n\n\t\t// Updates UI and state when dragging of the whole selected range\n\t\tthis._updateValueOnRangeDrag(e);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging a single Range Slider handle\n\t * @private\n\t */\n\t_updateValueOnHandleDrag(event: TouchEvent | MouseEvent) {\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst newValue = ctor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\t\tthis.update(this._valueAffected, newValue, undefined);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging of the whole selected range\n\t * @private\n\t */\n\t_updateValueOnRangeDrag(event: TouchEvent | MouseEvent) {\n\t\t// Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst currentPageXPos = ctor.getPageXValueFromEvent(event);\n\t\tconst newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX!);\n\n\t\t// No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n\t\tthis._setAffectedValue(undefined);\n\n\t\t// Update the UI and the state according to the calculated new values\n\t\tthis.update(undefined, newValues[0], newValues[1]);\n\t}\n\n\t_handleUp() {\n\t\tthis._setAffectedValueByFocusedElement();\n\t\tthis._setAffectedValue(undefined);\n\n\t\tif (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._setIsPressInCurrentRange(false);\n\t\tthis.handleUpBase();\n\n\t\tthis.rangePressed = false;\n\t\tthis._startValueAtBeginningOfAction = undefined;\n\t\tthis._endValueAtBeginningOfAction = undefined;\n\t}\n\n\t/**\n\t * Determines where the press occured and which values of the Range Slider\n\t * handles should be updated on further interaction.\n\t *\n\t * If the press is not in the selected range or over one of the Range Slider handles\n\t * determines which one from the value/endValue properties has to be updated\n\t * after the user action (based on closest handle).\n\t *\n\t * Set flags if the press is over a handle or in the selected range,\n\t * in such cases no values are changed on interaction start, but could be\n\t * updated later when dragging.\n\t * @private\n\t */\n\t_pressTargetAndAffectedValue(clientX: number, value: number) {\n\t\tconst startHandle = this.shadowRoot!.querySelector(\".ui5-slider-handle--start\")!;\n\t\tconst endHandle = this.shadowRoot!.querySelector(\".ui5-slider-handle--end\")!;\n\n\t\t// Check if the press point is in the bounds of any of the Range Slider handles\n\t\tconst handleStartDomRect = startHandle.getBoundingClientRect();\n\t\tconst handleEndDomRect = endHandle.getBoundingClientRect();\n\t\tconst inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n\t\tconst inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n\t\t// Remove the flag for value in current range if the press action is over one of the handles\n\t\tif (inHandleEndDom || inHandleStartDom) {\n\t\t\tthis._handeIsPressed = true;\n\t\t}\n\n\t\t// Return that handle that is closer to the press point\n\t\tif (inHandleEndDom || value > this.endValue) {\n\t\t\tthis._setAffectedValue(\"endValue\");\n\t\t}\n\n\t\t// If one of the handle is pressed return that one\n\t\tif (inHandleStartDom || value < this.startValue) {\n\t\t\tthis._setAffectedValue(\"startValue\");\n\t\t}\n\n\t\t// Flag if press is in the current select range\n\t\tconst isNewValueInCurrentRange = this._startValueAtBeginningOfAction !== undefined && this._endValueAtBeginningOfAction !== undefined && value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n\t\tthis._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n\t}\n\n\t/**\n\t * Sets the value property (start/end) that will get updated\n\t * by a user action depending on that user action's characteristics\n\t * - mouse press position - cursor coordinates relative to the start/end handles\n\t * - selected inner element via a keyboard navigation\n\t * @param affectedValue The value that will get modified by the interaction\n\t * @private\n\t */\n\t_setAffectedValue(affectedValue: AffectedValue | undefined) {\n\t\tthis._valueAffected = affectedValue;\n\n\t\t// If the values have been swapped reset the reversed flag\n\t\tif (this._areValuesReversed()) {\n\t\t\tthis._setValuesAreReversed();\n\t\t}\n\t}\n\n\t/**\n\t * Flag if press action is made on the currently selected range of values\n\t * @param isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n\t * @private\n\t */\n\t_setIsPressInCurrentRange(isPressInCurrentRange: boolean) {\n\t\tthis._isPressInCurrentRange = isPressInCurrentRange;\n\t}\n\n\t/**\n\t * Manage the focus between the focusable inner elements within the component.\n\t *\n\t * On initial focusin or if the whole range is affected by the user interaction\n\t * set the focus on the progress selection, otherwise on one of the Range Slider\n\t * handles based on the determined affected value by the user action.\n\t *\n\t * If one of the handles came across the other one in result of a user action\n\t * switch the focus between them to keep it visually consistent.\n\t *\n\t * Note:\n\t * In some cases this function is going to get called twice on one user action.\n\t *\n\t * 1. When the focus is initially set to an inner element it is done in the very beginning,\n\t * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n\t * is still not being received, causining an immediate focusout that we prevent by\n\t * calling this function once again.\n\t *\n\t * 2. When the focused is manually switched from one inner element to another.\n\t * The focusout handler is one and the same for all focusable parts within the\n\t * Range Slider and when is called it checks if it should keep the focus within\n\t * the component and which part of it should get focused if that is the case.\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (this._isPressInCurrentRange || !affectedValue) {\n\t\t\tthis._progressBar.focus();\n\t\t}\n\n\t\tif ((affectedValue === \"startValue\" && !isReversed) || (affectedValue === \"endValue\" && isReversed)) {\n\t\t\tthis._startHandle.focus();\n\t\t}\n\n\t\tif ((affectedValue === \"endValue\" && !isReversed) || (affectedValue === \"startValue\" && isReversed)) {\n\t\t\tthis._endHandle.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates startValue/endValue properties when the whole range is moved.\n\t *\n\t * Uses the change of the position of the start handle and adds the initially\n\t * selected range to it, to determine the whole range offset.\n\t * @param currentPageXPos The current horizontal position of the cursor/touch\n\t * @param initialStartHandlePageXPos The initial horizontal position of the start handle\n\t * @private\n\t */\n\t_calculateRangeOffset(currentPageXPos: number, initialStartHandlePageXPos: number) {\n\t\t// Return the current values if there is no difference in the\n\t\t// positions of the initial press and the current pointer\n\t\tif (this._initialPageXPosition === currentPageXPos) {\n\t\t\treturn [this.startValue, this.endValue];\n\t\t}\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst selectedRange = this.endValue - this.startValue;\n\n\t\t// Computes the new value based on the difference of the current cursor location from the start of the interaction\n\t\tlet startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n\t\t// When the end handle reaches the max possible value prevent the start handle from moving\n\t\t// And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tstartValue = ctor.clipValue(startValue, min, max - selectedRange);\n\n\t\treturn [startValue, startValue + selectedRange];\n\t}\n\n\t/**\n\t * Computes the new value based on the difference of the current cursor location from the\n\t * start of the interaction.\n\t * @param currentPageXPos The current horizontal position of the cursor/touch\n\t * @param initialStartHandlePageXPos The initial horizontal position of the start handle\n\t * @private\n\t */\n\t_calculateStartValueByOffset(currentPageXPos: number, initialStartHandlePageXPos: number) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst step = this._effectiveStep;\n\t\tconst dom = this.getBoundingClientRect();\n\n\t\tlet startValue;\n\t\tlet startValuePageX;\n\t\tlet positionOffset;\n\n\t\t/* Depending on the dragging direction:\n\t\t- calculate the new position of the start handle from its old pageX value combined with the movement offset;\n\t\t- calculate the start value based on its new pageX coordinates;\n\t\t- 'stepify' the calculated value based on the specified step property; */\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tif (currentPageXPos > this._initialPageXPosition!) {\n\t\t\t// Difference between the new position of the pointer and when the press event initial occured\n\t\t\tpositionOffset = currentPageXPos - this._initialPageXPosition!;\n\n\t\t\tstartValuePageX = initialStartHandlePageXPos + positionOffset;\n\t\t\tstartValue = ctor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = ctor.getSteppedValue(startValue, step, min);\n\t\t} else {\n\t\t\tpositionOffset = this._initialPageXPosition! - currentPageXPos;\n\t\t\tstartValuePageX = initialStartHandlePageXPos - positionOffset;\n\t\t\tstartValue = ctor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = ctor.getSteppedValue(startValue, step, min);\n\t\t}\n\n\t\treturn startValue;\n\t}\n\n\t/**\n\t * Updates the visual representation of the component by calculating\n\t * the styles of the handles and the range selection based on the new state.\n\t * @private\n\t */\n\t_updateHandlesAndRange(newValue: number) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\t\tconst prevStartValue = this.getStoredPropertyState(\"startValue\") || 0;\n\t\tconst prevEndValue = this.getStoredPropertyState(\"endValue\") || 0;\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// The value according to which we update the UI can be either the startValue\n\t\t// or the endValue property. It is determined in _getClosestHandle()\n\t\t// depending on to which handle is closer the user interaction.\n\t\tif (affectedValue === \"startValue\") {\n\t\t\tthis._selectedRange = (prevEndValue - newValue) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else if (affectedValue === \"endValue\") {\n\t\t\tthis._selectedRange = ((newValue - prevStartValue)) / (max - min);\n\t\t\tthis._secondHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else {\n\t\t\t// When both values are changed - UI sync or moving the whole selected range:\n\t\t\tthis._selectedRange = ((this.endValue - this.startValue)) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((this.startValue - min) / (max - min)) * 100;\n\t\t\tthis._secondHandlePositionFromStart = ((this.endValue - min) / (max - min)) * 100;\n\t\t}\n\t}\n\n\t/**\n\t * Swaps the start and end values of the handles if one came accros the other:\n\t * - If the start value is greater than the endValue swap them and their handles\n\t * - If the endValue become less than the start value swap them and their handles\n\t *\n\t * Switches the focus to the opposite of the currently focused handle.\n\t *\n\t * Note: Only the property values are reversed, the DOM elements of the handles\n\t * corresponding to them are never switched.\n\t * @private\n\t */\n\t_swapValues() {\n\t\tconst affectedValue = this._valueAffected;\n\t\tif (!affectedValue) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (affectedValue === \"startValue\" && this.startValue > this.endValue) {\n\t\t\tconst prevEndValue = this.endValue;\n\t\t\tthis.endValue = this.startValue;\n\t\t\tthis.startValue = prevEndValue;\n\t\t}\n\n\t\tif (affectedValue === \"endValue\" && this.endValue < this.startValue) {\n\t\t\tconst prevStartValue = this.startValue;\n\t\t\tthis.startValue = this.endValue;\n\t\t\tthis.endValue = prevStartValue;\n\t\t}\n\n\t\tthis._setValuesAreReversed();\n\t\tthis._updateHandlesAndRange(this[affectedValue]);\n\t\tthis.focusInnerElement();\n\t\tthis.syncUIAndState();\n\t}\n\n\t/**\n\t * Flag that we have swapped the values of the 'start' and 'end' properties,\n\t * to correctly switch the focus within the component from one handle to another\n\t * when the swapping is finished. As we only swap property values and not\n\t * the handle elements themselves, we must also swap their focus.\n\t * @private\n\t */\n\t_setValuesAreReversed() {\n\t\tthis._reversedValues = !this._reversedValues;\n\t }\n\n\t _areValuesReversed() {\n\t\treturn this._reversedValues;\n\t}\n\n\tget tickmarksObject() {\n\t\tconst count = this._tickmarksCount;\n\t\tconst arr = [];\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn [false, false];\n\t\t}\n\n\t\tfor (let i = 0; i <= count; i++) {\n\t\t\tconst isBiggerThanStartValue = this._effectiveMin + (i * this.step) >= this.startValue;\n\t\t\tconst isBiggerThanEndValue = this._effectiveMin + (i * this.step) <= this.endValue;\n\n\t\t\tarr.push(isBiggerThanStartValue && isBiggerThanEndValue);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tget _startHandle() {\n\t\treturn this.shadowRoot!.querySelector<HTMLElement>(\".ui5-slider-handle--start\")!;\n\t}\n\n\tget _endHandle() {\n\t\treturn this.shadowRoot!.querySelector<HTMLElement>(\".ui5-slider-handle--end\")!;\n\t}\n\n\tget _progressBar() {\n\t\treturn this.shadowRoot!.querySelector<HTMLElement>(\".ui5-slider-progress\")!;\n\t}\n\n\tget _ariaLabelledByStartHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-startHandleDesc`].join(\" \").trim();\n\t}\n\n\tget _ariaLabelledByEndHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-endHandleDesc`].join(\" \").trim();\n\t}\n\n\tget _ariaLabelledByProgressBarRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"width\": `${this._selectedRange! * 100}%`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart!}%`,\n\t\t\t},\n\t\t\tstartHandle: {\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart!}%`,\n\t\t\t},\n\t\t\tendHandle: {\n\t\t\t\t[this.directionStart]: `${this._secondHandlePositionFromStart!}%`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async onDefine() {\n\t\tRangeSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n\t}\n}\n\nRangeSlider.define();\n\nexport default RangeSlider;\n"]}