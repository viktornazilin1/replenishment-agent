{
  "version": 3,
  "sources": ["../../../src/decorators/bound.ts"],
  "sourcesContent": ["export default function bound(target: any, key: string | symbol, descriptor: any): any {\n\tif (!(typeof target[key] === \"function\")) {\n\t\tthrow new Error(`@bound decorator can only be applied to methods, received ${String(key)}: ${typeof target[key]}`);\n\t}\n\n\tlet fn = descriptor.value;\n\treturn {\n\t\tconfigurable: true,\n\t\tget(): any {\n\t\t\tif (!(this instanceof target.constructor)) {\n\t\t\t\treturn fn;\n\t\t\t}\n\n\t\t\t// if the property is already defined on the instance, then this call is a super call\n\t\t\tif (Object.hasOwnProperty.call(this, key)) {\n\t\t\t\treturn fn;\n\t\t\t}\n\n\t\t\tlet boundFn = fn.bind(this);\n\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget(): any {\n\t\t\t\t\treturn boundFn;\n\t\t\t\t},\n\t\t\t\tset(value: any): void {\n\t\t\t\t\t// setting a value on the instance means they overwrite the default behaviour\n\t\t\t\t\tboundFn = value;\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn boundFn;\n\t\t},\n\t\tset(value: any): void {\n\t\t\tfn = value;\n\t\t},\n\t};\n}\n"],
  "mappings": "aAAA,wBAAwBA,EAAMC,EAAaC,EAAsBC,EAAsB,CACtF,GAAM,OAAOF,EAAOC,CAAG,GAAM,WAC5B,MAAM,IAAI,MAAM,6DAA6D,OAAOA,CAAG,CAAC,KAAK,OAAOD,EAAOC,CAAG,CAAC,EAAE,EAGlH,IAAIE,EAAKD,EAAW,MACpB,MAAO,CACN,aAAc,GACd,KAAW,CAMV,GALI,EAAE,gBAAgBF,EAAO,cAKzB,OAAO,eAAe,KAAK,KAAMC,CAAG,EACvC,OAAOE,EAGR,IAAIC,EAAUD,EAAG,KAAK,IAAI,EAE1B,cAAO,eAAe,KAAMF,EAAK,CAChC,aAAc,GACd,KAAW,CACV,OAAOG,CACR,EACA,IAAIC,EAAkB,CAErBD,EAAUC,CACX,CACD,CAAC,EACMD,CACR,EACA,IAAIC,EAAkB,CACrBF,EAAKE,CACN,CACD,CACD",
  "names": ["bound", "target", "key", "descriptor", "fn", "boundFn", "value"]
}
