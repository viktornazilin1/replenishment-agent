{
  "version": 3,
  "sources": ["../../src/connectToComponent.ts"],
  "sourcesContent": ["import type UI5Element from \"./UI5Element.js\";\nimport { renderDeferred } from \"./Render.js\";\nimport type { Interval } from \"./types.js\";\n\nconst MISSING_ELEMENT_POLL_TIMEOUT = 500; // how often to poll for not-yet-in-DOM friend elements\nconst connections = new Map<string, HTMLElement>();\nconst intervals = new Map<string, Interval>();\n\ntype ConnectOptions = {\n\thost: UI5Element;\n\tpropName: string;\n\tonConnect?: (friend: HTMLElement) => void;\n\tonDisconnect?: (friend: HTMLElement) => void;\n}\n\nconst connectToComponent = (options: ConnectOptions): HTMLElement | undefined => {\n\tconst host = options.host;\n\tconst propName = options.propName;\n\tconst friend = host[propName as keyof typeof host] as HTMLElement | string | undefined;\n\n\tlet connectedTo: HTMLElement | undefined;\n\tif (friend === undefined || friend === \"\") {\n\t\tconnectedTo = undefined; // do not return early even if a \"menu\" property is not set - it may have been set before and cleanup must run\n\t} else if (friend instanceof HTMLElement) {\n\t\tconnectedTo = friend;\n\t} else {\n\t\tconst rootNode = host.getRootNode() as Document;\n\t\tconnectedTo = (rootNode.getElementById && rootNode.getElementById(friend)) || undefined;\n\t}\n\n\tconst key = `${host._id}-${propName}`;\n\tconst prevConnectedTo = connections.get(key);\n\n\t// Not connected - return undefined\n\tif (!connectedTo) {\n\t\tif (prevConnectedTo) { // but first disconnect, if needed\n\t\t\toptions.onDisconnect && options.onDisconnect(prevConnectedTo);\n\t\t\tconnections.delete(key);\n\t\t}\n\n\t\t// if friend element not in DOM yet, start polling\n\t\tif (typeof friend === \"string\" && friend && !intervals.has(key)) {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tconst rootNode = host.getRootNode() as Document;\n\t\t\t\tconst found = (rootNode.getElementById && rootNode.getElementById(friend));\n\n\t\t\t\tif (found) {\n\t\t\t\t\tclearInterval(intervals.get(key));\n\t\t\t\t\tintervals.delete(key);\n\t\t\t\t\trenderDeferred(host);\n\t\t\t\t}\n\t\t\t}, MISSING_ELEMENT_POLL_TIMEOUT);\n\t\t\tintervals.set(key, interval);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// If connected, but still polling, stop polling\n\tif (intervals.has(key)) {\n\t\tclearInterval(intervals.get(key));\n\t\tintervals.delete(key);\n\t}\n\n\t// Connected - either for the first time, or to something else\n\tif (prevConnectedTo !== connectedTo) {\n\t\tif (prevConnectedTo) {\n\t\t\toptions.onDisconnect && options.onDisconnect(prevConnectedTo);\n\t\t}\n\t\toptions.onConnect && options.onConnect(connectedTo);\n\t\tconnections.set(key, connectedTo);\n\t}\n\n\treturn connections.get(key);\n};\n\nexport default connectToComponent;\n"],
  "mappings": "aACA,OAAS,kBAAAA,MAAsB,cAG/B,MAAMC,EAA+B,IAC/BC,EAAc,IAAI,IAClBC,EAAY,IAAI,IAShBC,EAAsBC,GAAqD,CAChF,MAAMC,EAAOD,EAAQ,KACfE,EAAWF,EAAQ,SACnBG,EAASF,EAAKC,CAA6B,EAEjD,IAAIE,EACJ,GAAID,IAAW,QAAaA,IAAW,GACtCC,EAAc,eACJD,aAAkB,YAC5BC,EAAcD,MACR,CACN,MAAME,EAAWJ,EAAK,YAAY,EAClCG,EAAeC,EAAS,gBAAkBA,EAAS,eAAeF,CAAM,GAAM,MAC/E,CAEA,MAAMG,EAAM,GAAGL,EAAK,GAAG,IAAIC,CAAQ,GAC7BK,EAAkBV,EAAY,IAAIS,CAAG,EAG3C,GAAI,CAACF,EAAa,CAOjB,GANIG,IACHP,EAAQ,cAAgBA,EAAQ,aAAaO,CAAe,EAC5DV,EAAY,OAAOS,CAAG,GAInB,OAAOH,GAAW,UAAYA,GAAU,CAACL,EAAU,IAAIQ,CAAG,EAAG,CAChE,MAAME,EAAW,YAAY,IAAM,CAClC,MAAMH,EAAWJ,EAAK,YAAY,EACnBI,EAAS,gBAAkBA,EAAS,eAAeF,CAAM,IAGvE,cAAcL,EAAU,IAAIQ,CAAG,CAAC,EAChCR,EAAU,OAAOQ,CAAG,EACpBX,EAAeM,CAAI,EAErB,EAAGL,CAA4B,EAC/BE,EAAU,IAAIQ,EAAKE,CAAQ,CAC5B,CAEA,MACD,CAGA,OAAIV,EAAU,IAAIQ,CAAG,IACpB,cAAcR,EAAU,IAAIQ,CAAG,CAAC,EAChCR,EAAU,OAAOQ,CAAG,GAIjBC,IAAoBH,IACnBG,GACHP,EAAQ,cAAgBA,EAAQ,aAAaO,CAAe,EAE7DP,EAAQ,WAAaA,EAAQ,UAAUI,CAAW,EAClDP,EAAY,IAAIS,EAAKF,CAAW,GAG1BP,EAAY,IAAIS,CAAG,CAC3B,EAEA,eAAeP",
  "names": ["renderDeferred", "MISSING_ELEMENT_POLL_TIMEOUT", "connections", "intervals", "connectToComponent", "options", "host", "propName", "friend", "connectedTo", "rootNode", "key", "prevConnectedTo", "interval"]
}
