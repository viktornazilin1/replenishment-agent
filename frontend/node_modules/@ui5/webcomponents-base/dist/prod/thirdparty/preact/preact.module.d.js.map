{
  "version": 3,
  "sources": ["../../../../src/thirdparty/preact/preact.module.d.ts"],
  "sourcesContent": ["export as namespace preact;\n\nimport { JSXInternal } from './jsx';\n\nexport import JSX = JSXInternal;\n\n//\n// Preact Virtual DOM\n// -----------------------------------\n\nexport interface VNode<P = {}> {\n\ttype: ComponentType<P> | string;\n\tprops: P & { children: ComponentChildren };\n\tkey: Key;\n\t/**\n\t * ref is not guaranteed by React.ReactElement, for compatibility reasons\n\t * with popular react libs we define it as optional too\n\t */\n\tref?: Ref<any> | null;\n\t/**\n\t * The time this `vnode` started rendering. Will only be set when\n\t * the devtools are attached.\n\t * Default value: `0`\n\t */\n\tstartTime?: number;\n\t/**\n\t * The time that the rendering of this `vnode` was completed. Will only be\n\t * set when the devtools are attached.\n\t * Default value: `-1`\n\t */\n\tendTime?: number;\n}\n\n//\n// Preact Component interface\n// -----------------------------------\n\nexport type Key = string | number | any;\n\nexport type RefObject<T> = { current: T | null };\nexport type RefCallback<T> = (instance: T | null) => void;\nexport type Ref<T> = RefObject<T> | RefCallback<T> | null;\n\nexport type ComponentChild =\n\t| VNode<any>\n\t| object\n\t| string\n\t| number\n\t| bigint\n\t| boolean\n\t| null\n\t| undefined;\nexport type ComponentChildren = ComponentChild[] | ComponentChild;\n\nexport interface Attributes {\n\tkey?: Key | undefined;\n\tjsx?: boolean | undefined;\n}\n\nexport interface ClassAttributes<T> extends Attributes {\n\tref?: Ref<T>;\n}\n\nexport interface PreactDOMAttributes {\n\tchildren?: ComponentChildren;\n\tdangerouslySetInnerHTML?: {\n\t\t__html: string;\n\t};\n}\n\nexport interface ErrorInfo {\n\tcomponentStack?: string;\n}\n\nexport type RenderableProps<P, RefType = any> = P &\n\tReadonly<Attributes & { children?: ComponentChildren; ref?: Ref<RefType> }>;\n\nexport type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\nexport type ComponentFactory<P = {}> = ComponentType<P>;\n\nexport type ComponentProps<\n\tC extends ComponentType<any> | keyof JSXInternal.IntrinsicElements\n> = C extends ComponentType<infer P>\n\t? P\n\t: C extends keyof JSXInternal.IntrinsicElements\n\t\t? JSXInternal.IntrinsicElements[C]\n\t\t: never;\n\nexport interface FunctionComponent<P = {}> {\n\t(props: RenderableProps<P>, context?: any): ComponentChildren;\n\tdisplayName?: string;\n\tdefaultProps?: Partial<P> | undefined;\n}\nexport interface FunctionalComponent<P = {}> extends FunctionComponent<P> {}\n\nexport interface ComponentClass<P = {}, S = {}> {\n\tnew (props: P, context?: any): Component<P, S>;\n\tdisplayName?: string;\n\tdefaultProps?: Partial<P>;\n\tcontextType?: Context<any>;\n\tgetDerivedStateFromProps?(\n\t\tprops: Readonly<P>,\n\t\tstate: Readonly<S>\n\t): Partial<S> | null;\n\tgetDerivedStateFromError?(error: any): Partial<S> | null;\n}\nexport interface ComponentConstructor<P = {}, S = {}>\n\textends ComponentClass<P, S> {}\n\n// Type alias for a component instance considered generally, whether stateless or stateful.\nexport type AnyComponent<P = {}, S = {}> =\n\t| FunctionComponent<P>\n\t| ComponentConstructor<P, S>;\n\nexport interface Component<P = {}, S = {}> {\n\tcomponentWillMount?(): void;\n\tcomponentDidMount?(): void;\n\tcomponentWillUnmount?(): void;\n\tgetChildContext?(): object;\n\tcomponentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\n\tshouldComponentUpdate?(\n\t\tnextProps: Readonly<P>,\n\t\tnextState: Readonly<S>,\n\t\tnextContext: any\n\t): boolean;\n\tcomponentWillUpdate?(\n\t\tnextProps: Readonly<P>,\n\t\tnextState: Readonly<S>,\n\t\tnextContext: any\n\t): void;\n\tgetSnapshotBeforeUpdate?(oldProps: Readonly<P>, oldState: Readonly<S>): any;\n\tcomponentDidUpdate?(\n\t\tpreviousProps: Readonly<P>,\n\t\tpreviousState: Readonly<S>,\n\t\tsnapshot: any\n\t): void;\n\tcomponentDidCatch?(error: any, errorInfo: ErrorInfo): void;\n}\n\nexport abstract class Component<P, S> {\n\tconstructor(props?: P, context?: any);\n\n\tstatic displayName?: string;\n\tstatic defaultProps?: any;\n\tstatic contextType?: Context<any>;\n\n\t// Static members cannot reference class type parameters. This is not\n\t// supported in TypeScript. Reusing the same type arguments from `Component`\n\t// will lead to an impossible state where one cannot satisfy the type\n\t// constraint under no circumstances, see #1356.In general type arguments\n\t// seem to be a bit buggy and not supported well at the time of this\n\t// writing with TS 3.3.3333.\n\tstatic getDerivedStateFromProps?(\n\t\tprops: Readonly<object>,\n\t\tstate: Readonly<object>\n\t): object | null;\n\tstatic getDerivedStateFromError?(error: any): object | null;\n\n\tstate: Readonly<S>;\n\tprops: RenderableProps<P>;\n\tcontext: any;\n\tbase?: Element | Text;\n\n\t// From https://github.com/DefinitelyTyped/DefinitelyTyped/blob/e836acc75a78cf0655b5dfdbe81d69fdd4d8a252/types/react/index.d.ts#L402\n\t// // We MUST keep setState() as a unified signature because it allows proper checking of the method return type.\n\t// // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257\n\tsetState<K extends keyof S>(\n\t\tstate:\n\t\t\t| ((\n\t\t\t\t\tprevState: Readonly<S>,\n\t\t\t\t\tprops: Readonly<P>\n\t\t\t  ) => Pick<S, K> | Partial<S> | null)\n\t\t\t| (Pick<S, K> | Partial<S> | null),\n\t\tcallback?: () => void\n\t): void;\n\n\tforceUpdate(callback?: () => void): void;\n\n\tabstract render(\n\t\tprops?: RenderableProps<P>,\n\t\tstate?: Readonly<S>,\n\t\tcontext?: any\n\t): ComponentChildren;\n}\n\n//\n// Preact createElement\n// -----------------------------------\n\nexport function createElement(\n\ttype: 'input',\n\tprops:\n\t\t| (JSXInternal.DOMAttributes<HTMLInputElement> &\n\t\t\t\tClassAttributes<HTMLInputElement>)\n\t\t| null,\n\t...children: ComponentChildren[]\n): VNode<\n\tJSXInternal.DOMAttributes<HTMLInputElement> &\n\t\tClassAttributes<HTMLInputElement>\n>;\nexport function createElement<\n\tP extends JSXInternal.HTMLAttributes<T>,\n\tT extends HTMLElement\n>(\n\ttype: keyof JSXInternal.IntrinsicElements,\n\tprops: (ClassAttributes<T> & P) | null,\n\t...children: ComponentChildren[]\n): VNode<ClassAttributes<T> & P>;\nexport function createElement<\n\tP extends JSXInternal.SVGAttributes<T>,\n\tT extends HTMLElement\n>(\n\ttype: keyof JSXInternal.IntrinsicSVGElements,\n\tprops: (ClassAttributes<T> & P) | null,\n\t...children: ComponentChildren[]\n): VNode<ClassAttributes<T> & P>;\nexport function createElement<T extends HTMLElement>(\n\ttype: string,\n\tprops:\n\t\t| (ClassAttributes<T> &\n\t\t\t\tJSXInternal.HTMLAttributes &\n\t\t\t\tJSXInternal.SVGAttributes)\n\t\t| null,\n\t...children: ComponentChildren[]\n): VNode<\n\tClassAttributes<T> & JSXInternal.HTMLAttributes & JSXInternal.SVGAttributes\n>;\nexport function createElement<P>(\n\ttype: ComponentType<P> | string,\n\tprops: (Attributes & P) | null,\n\t...children: ComponentChildren[]\n): VNode<P>;\nexport namespace createElement {\n\texport import JSX = JSXInternal;\n}\n\nexport function h(\n\ttype: 'input',\n\tprops:\n\t\t| (JSXInternal.DOMAttributes<HTMLInputElement> &\n\t\t\t\tClassAttributes<HTMLInputElement>)\n\t\t| null,\n\t...children: ComponentChildren[]\n): VNode<\n\tJSXInternal.DOMAttributes<HTMLInputElement> &\n\t\tClassAttributes<HTMLInputElement>\n>;\nexport function h<\n\tP extends JSXInternal.HTMLAttributes<T>,\n\tT extends HTMLElement\n>(\n\ttype: keyof JSXInternal.IntrinsicElements,\n\tprops: (ClassAttributes<T> & P) | null,\n\t...children: ComponentChildren[]\n): VNode<ClassAttributes<T> & P>;\nexport function h<\n\tP extends JSXInternal.SVGAttributes<T>,\n\tT extends HTMLElement\n>(\n\ttype: keyof JSXInternal.IntrinsicSVGElements,\n\tprops: (ClassAttributes<T> & P) | null,\n\t...children: ComponentChildren[]\n): VNode<ClassAttributes<T> & P>;\nexport function h<T extends HTMLElement>(\n\ttype: string,\n\tprops:\n\t\t| (ClassAttributes<T> &\n\t\t\t\tJSXInternal.HTMLAttributes &\n\t\t\t\tJSXInternal.SVGAttributes)\n\t\t| null,\n\t...children: ComponentChildren[]\n): VNode<\n\t| (ClassAttributes<T> &\n\t\t\tJSXInternal.HTMLAttributes &\n\t\t\tJSXInternal.SVGAttributes)\n\t| null\n>;\nexport function h<P>(\n\ttype: ComponentType<P> | string,\n\tprops: (Attributes & P) | null,\n\t...children: ComponentChildren[]\n): VNode<Attributes & P>;\nexport namespace h {\n\texport import JSX = JSXInternal;\n}\n\n//\n// Preact render\n// -----------------------------------\ninterface ContainerNode {\n\treadonly nodeType: number;\n\treadonly parentNode: ContainerNode | null;\n\treadonly firstChild: ContainerNode | null;\n\treadonly childNodes: ArrayLike<ContainerNode>;\n\n\tcontains(other: ContainerNode | null): boolean;\n\tinsertBefore(node: ContainerNode, child: ContainerNode | null): ContainerNode;\n\tappendChild(node: ContainerNode): ContainerNode;\n\tremoveChild(child: ContainerNode): ContainerNode;\n}\n\nexport function render(vnode: ComponentChild, parent: ContainerNode): void;\n/**\n * @deprecated Will be removed in v11.\n *\n * Replacement Preact 10+ implementation can be found here: https://gist.github.com/developit/f4c67a2ede71dc2fab7f357f39cff28c\n */\nexport function render(\n\tvnode: ComponentChild,\n\tparent: ContainerNode,\n\treplaceNode?: Element | Text\n): void;\nexport function hydrate(vnode: ComponentChild, parent: ContainerNode): void;\nexport function cloneElement(\n\tvnode: VNode<any>,\n\tprops?: any,\n\t...children: ComponentChildren[]\n): VNode<any>;\nexport function cloneElement<P>(\n\tvnode: VNode<P>,\n\tprops?: any,\n\t...children: ComponentChildren[]\n): VNode<P>;\n\n//\n// Preact Built-in Components\n// -----------------------------------\n\n// TODO: Revisit what the public type of this is...\nexport let Fragment: FunctionComponent<{}>;\n\n//\n// Preact options\n// -----------------------------------\n\n/**\n * Global options for preact\n */\nexport interface Options {\n\t/** Attach a hook that is invoked whenever a VNode is created. */\n\tvnode?(vnode: VNode): void;\n\t/** Attach a hook that is invoked immediately before a vnode is unmounted. */\n\tunmount?(vnode: VNode): void;\n\t/** Attach a hook that is invoked after a vnode has rendered. */\n\tdiffed?(vnode: VNode): void;\n\tevent?(e: Event): any;\n\trequestAnimationFrame?(callback: () => void): void;\n\tdebounceRendering?(cb: () => void): void;\n\tuseDebugValue?(value: string | number): void;\n\t_addHookName?(name: string | number): void;\n\t__suspenseDidResolve?(vnode: VNode, cb: () => void): void;\n\t// __canSuspenseResolve?(vnode: VNode, cb: () => void): void;\n\n\t/**\n\t * Customize attribute serialization when a precompiled JSX transform\n\t * is used.\n\t */\n\tattr?(name: string, value: any): string | void;\n}\n\nexport let options: Options;\n\n//\n// Preact helpers\n// -----------------------------------\nexport function createRef<T = any>(): RefObject<T>;\nexport function toChildArray(\n\tchildren: ComponentChildren\n): Array<VNode | string | number>;\nexport function isValidElement(vnode: any): vnode is VNode;\n\n//\n// Context\n// -----------------------------------\nexport interface Consumer<T>\n\textends FunctionComponent<{\n\t\tchildren: (value: T) => ComponentChildren;\n\t}> {}\nexport interface PreactConsumer<T> extends Consumer<T> {}\n\nexport interface Provider<T>\n\textends FunctionComponent<{\n\t\tvalue: T;\n\t\tchildren?: ComponentChildren;\n\t}> {}\nexport interface PreactProvider<T> extends Provider<T> {}\nexport type ContextType<C extends Context<any>> = C extends Context<infer T>\n\t? T\n\t: never;\n\nexport interface Context<T> {\n\tConsumer: Consumer<T>;\n\tProvider: Provider<T>;\n\tdisplayName?: string;\n}\nexport interface PreactContext<T> extends Context<T> {}\n\nexport function createContext<T>(defaultValue: T): Context<T>;\n"],
  "mappings": "aAEA,OAAS,eAAAA,MAAmB,QAErB,aAAO,IAAMA,EAuIb,aAAe,SAAgB,CA4CtC,CAiDO,WAAU,eAAAC,GACFA,EAAA,IAAMD,GADJ,oBAkDV,WAAU,GAAAE,GACFA,EAAA,IAAMF,GADJ,QA+CV,WAAI,SA+BA",
  "names": ["JSXInternal", "createElement", "h"]
}
