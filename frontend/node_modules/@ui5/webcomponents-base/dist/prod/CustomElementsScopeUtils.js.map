{
  "version": 3,
  "sources": ["../../src/CustomElementsScopeUtils.ts"],
  "sourcesContent": ["import { hasRegisteredTags } from \"./CustomElementsRegistry.js\";\nimport VersionInfo from \"./generated/VersionInfo.js\";\n\nlet suf: string;\n\ntype Rules = {\n\tinclude: Array<RegExp>,\n\texclude: Array<RegExp>,\n};\n\nlet rulesObj: Rules = {\n\tinclude: [/^ui5-/],\n\texclude: [],\n};\n\nconst tagsCache = new Map<string, boolean>(); // true/false means the tag should/should not be cached, undefined means not known yet.\n\n/**\n * Sets the suffix to be used for custom elements scoping, f.e. pass \"demo\" to get tags such as \"ui5-button-demo\".\n *\n * **Note:** By default all tags starting with \"ui5-\" will be scoped, unless you change this by calling \"setCustomElementsScopingRules\"\n * **Note:** Setting the scoping suffix must be done before importing any components.\n *\n * @public\n * @param suffix The scoping suffix\n */\nconst setCustomElementsScopingSuffix = (suffix: string) => {\n\tif (!suffix.match(/^[a-zA-Z0-9_-]+$/)) {\n\t\tthrow new Error(\"Only alphanumeric characters and dashes allowed for the scoping suffix\");\n\t}\n\n\tif (hasRegisteredTags()) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(\"Setting the scoping suffix must be done before importing any components. For proper usage, read the scoping section: https://github.com/SAP/ui5-webcomponents/blob/main/docs/2-advanced/06-scoping.md.\");\n\t}\n\n\tsuf = suffix;\n};\n\n/**\n * Returns the currently set scoping suffix, or undefined if not set.\n *\n * @public\n * @returns {String|undefined}\n */\nconst getCustomElementsScopingSuffix = () => {\n\treturn suf;\n};\n\n/**\n * Sets the rules, governing which custom element tags to scope and which not, f.e.\n * setCustomElementsScopingRules({include: [/^ui5-/]}, exclude: [/^ui5-mylib-/, /^ui5-carousel$/]);\n * will scope all elements starting with \"ui5-\" but not the ones starting with \"ui5-mylib-\" and not \"ui5-carousel\".\n *\n * @public\n * @param rules Object with \"include\" and \"exclude\" properties, both arrays of regular expressions. Note that \"include\"\n * rules are applied first and \"exclude\" rules second.\n */\nconst setCustomElementsScopingRules = (rules: Rules) => {\n\tif (!rules || !rules.include) {\n\t\tthrow new Error(`\"rules\" must be an object with at least an \"include\" property`);\n\t}\n\n\tif (!Array.isArray(rules.include) || rules.include.some(rule => !(rule instanceof RegExp))) {\n\t\tthrow new Error(`\"rules.include\" must be an array of regular expressions`);\n\t}\n\n\tif (rules.exclude && (!Array.isArray(rules.exclude) || rules.exclude.some(rule => !(rule instanceof RegExp)))) {\n\t\tthrow new Error(`\"rules.exclude\" must be an array of regular expressions`);\n\t}\n\n\trules.exclude = rules.exclude || [];\n\trulesObj = rules;\n\ttagsCache.clear(); // reset the cache upon setting new rules\n};\n\n/**\n * Returns the rules, governing which custom element tags to scope and which not. By default, all elements\n * starting with \"ui5-\" are scoped. The default rules are: {include: [/^ui5-/]}.\n *\n * @public\n * @returns {Object}\n */\nconst getCustomElementsScopingRules = () => {\n\treturn rulesObj;\n};\n\n/**\n * Determines whether custom elements with the given tag should be scoped or not.\n * The tag is first matched against the \"include\" rules and then against the \"exclude\" rules and the\n * result is cached until new rules are set.\n *\n * @public\n * @param tag\n */\nconst shouldScopeCustomElement = (tag: string) => {\n\tif (!tagsCache.has(tag)) {\n\t\tconst result = rulesObj.include.some(rule => tag.match(rule)) && !rulesObj.exclude.some(rule => tag.match(rule));\n\t\ttagsCache.set(tag, result);\n\t}\n\n\treturn tagsCache.get(tag);\n};\n\n/**\n * Returns the currently set scoping suffix, if any and if the tag should be scoped, or undefined otherwise.\n *\n * @public\n * @param tag\n * @returns {String}\n */\nconst getEffectiveScopingSuffixForTag = (tag: string) => {\n\tif (shouldScopeCustomElement(tag)) {\n\t\treturn getCustomElementsScopingSuffix();\n\t}\n};\n\n/**\n * @public\n * Used for getting a scoped name for a CSS variable using the same transformation used in the build\n * @name the name of the css variable as written in the code\n * @returns a variable name with the current version inserted as available at runtime\n */\nconst getScopedVarName = (name: string) => {\n\tconst versionStr = `v${VersionInfo.version.replaceAll(\".\", \"-\")}`;\n\tconst expr = /(--_?ui5)([^,:)\\s]+)/g;\n\treturn name.replaceAll(expr, `$1-${versionStr}$2`);\n};\n\nexport {\n\tsetCustomElementsScopingSuffix,\n\tgetCustomElementsScopingSuffix,\n\tsetCustomElementsScopingRules,\n\tgetCustomElementsScopingRules,\n\tshouldScopeCustomElement,\n\tgetEffectiveScopingSuffixForTag,\n\tgetScopedVarName,\n};\n"],
  "mappings": "aAAA,OAAS,qBAAAA,MAAyB,8BAClC,OAAOC,MAAiB,6BAExB,IAAIC,EAOAC,EAAkB,CACrB,QAAS,CAAC,OAAO,EACjB,QAAS,CAAC,CACX,EAEA,MAAMC,EAAY,IAAI,IAWhBC,EAAkCC,GAAmB,CAC1D,GAAI,CAACA,EAAO,MAAM,kBAAkB,EACnC,MAAM,IAAI,MAAM,wEAAwE,EAGrFN,EAAkB,GAErB,QAAQ,KAAK,wMAAwM,EAGtNE,EAAMI,CACP,EAQMC,EAAiC,IAC/BL,EAYFM,EAAiCC,GAAiB,CACvD,GAAI,CAACA,GAAS,CAACA,EAAM,QACpB,MAAM,IAAI,MAAM,+DAA+D,EAGhF,GAAI,CAAC,MAAM,QAAQA,EAAM,OAAO,GAAKA,EAAM,QAAQ,KAAKC,GAAQ,EAAEA,aAAgB,OAAO,EACxF,MAAM,IAAI,MAAM,yDAAyD,EAG1E,GAAID,EAAM,UAAY,CAAC,MAAM,QAAQA,EAAM,OAAO,GAAKA,EAAM,QAAQ,KAAKC,GAAQ,EAAEA,aAAgB,OAAO,GAC1G,MAAM,IAAI,MAAM,yDAAyD,EAG1ED,EAAM,QAAUA,EAAM,SAAW,CAAC,EAClCN,EAAWM,EACXL,EAAU,MAAM,CACjB,EASMO,EAAgC,IAC9BR,EAWFS,EAA4BC,GAAgB,CACjD,GAAI,CAACT,EAAU,IAAIS,CAAG,EAAG,CACxB,MAAMC,EAASX,EAAS,QAAQ,KAAKO,GAAQG,EAAI,MAAMH,CAAI,CAAC,GAAK,CAACP,EAAS,QAAQ,KAAKO,GAAQG,EAAI,MAAMH,CAAI,CAAC,EAC/GN,EAAU,IAAIS,EAAKC,CAAM,CAC1B,CAEA,OAAOV,EAAU,IAAIS,CAAG,CACzB,EASME,EAAmCF,GAAgB,CACxD,GAAID,EAAyBC,CAAG,EAC/B,OAAON,EAA+B,CAExC,EAQMS,EAAoBC,GAAiB,CAC1C,MAAMC,EAAa,IAAIjB,EAAY,QAAQ,WAAW,IAAK,GAAG,CAAC,GACzDkB,EAAO,wBACb,OAAOF,EAAK,WAAWE,EAAM,MAAMD,CAAU,IAAI,CAClD,EAEA,OACCb,KAAA,+BACAE,KAAA,+BACAC,KAAA,8BACAG,KAAA,8BACAC,KAAA,yBACAG,KAAA,gCACAC,KAAA",
  "names": ["hasRegisteredTags", "VersionInfo", "suf", "rulesObj", "tagsCache", "setCustomElementsScopingSuffix", "suffix", "getCustomElementsScopingSuffix", "setCustomElementsScopingRules", "rules", "rule", "getCustomElementsScopingRules", "shouldScopeCustomElement", "tag", "result", "getEffectiveScopingSuffixForTag", "getScopedVarName", "name", "versionStr", "expr"]
}
