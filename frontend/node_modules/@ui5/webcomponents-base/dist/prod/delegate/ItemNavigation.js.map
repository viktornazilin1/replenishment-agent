{
  "version": 3,
  "sources": ["../../../src/delegate/ItemNavigation.ts"],
  "sourcesContent": ["import {\n\tisDown,\n\tisUp,\n\tisLeft,\n\tisRight,\n\tisHome,\n\tisEnd,\n\tisPageDown,\n\tisPageUp,\n} from \"../Keys.js\";\nimport getActiveElement from \"../util/getActiveElement.js\";\n\nimport NavigationMode from \"../types/NavigationMode.js\";\nimport ItemNavigationBehavior from \"../types/ItemNavigationBehavior.js\";\n\nimport type UI5Element from \"../UI5Element.js\";\nimport { instanceOfUI5Element } from \"../UI5Element.js\";\n\ninterface ITabbable {\n\tid: string,\n\tforcedTabIndex?: string,\n}\n\ntype ItemNavigationOptions = {\n\tcurrentIndex?: number,\n\tnavigationMode?: NavigationMode,\n\trowSize?: number\n\tskipItemsSize?: number,\n\tbehavior?: ItemNavigationBehavior,\n\tgetItemsCallback: () => Array<ITabbable>,\n\taffectedPropertiesNames?: Array<string>,\n};\n\n/**\n * The ItemNavigation class manages the calculations to determine the correct \"tabindex\" for a group of related items inside a root component.\n * Important: ItemNavigation only does the calculations and does not change \"tabindex\" directly, this is a responsibility of the developer.\n *\n * The keys that trigger ItemNavigation are:\n *  - Up/down\n *  - Left/right\n *  - Home/End\n *\n * Usage:\n * 1) Use the \"getItemsCallback\" constructor property to pass a callback to ItemNavigation, which, whenever called, will return the list of items to navigate among.\n *\n * Each item passed to ItemNavigation via \"getItemsCallback\" must be:\n *  - A) either a UI5Element with a \"forcedTabIndex\" property\n *  - B) or an Object with \"id\" and \"forcedTabIndex\" properties which represents a part of the root component's shadow DOM.\n *    The \"id\" must be a valid ID within the shadow root of the component ItemNavigation operates on.\n *    This object must not be a DOM object because, as said, ItemNavigation will not set \"tabindex\" on it. It must be a representation of a DOM object only\n *    and the developer has the responsibility to update the \"tabindex\" in the component's DOM.\n *  - C) a combination of the above\n *\n * Whenever the user navigates with the keyboard, ItemNavigation will modify the \"forcedTabIndex\" properties of the items.\n * It is the items' responsibilities to re-render themselves and apply the correct value of \"tabindex\" (i.e. to map the \"forcedTabIndex\" ItemNavigation set to them to the \"tabindex\" property).\n * If the items of the ItemNavigation are UI5Elements themselves, this can happen naturally since they will be invalidated by their \"forcedTabIndex\" property.\n * If the items are Objects with \"id\" and \"forcedTabIndex\" however, it is the developer's responsibility to apply these and the easiest way is to have the root component invalidated by ItemNavigation.\n * To do so, set the \"affectedPropertiesNames\" constructor property to point to one or more of the root component's properties that need refreshing when \"forcedTabIndex\" is changed deeply.\n *\n * 2) Call the \"setCurrentItem\" method of ItemNavigation whenever you want to change the current item.\n * This is most commonly required if the user for example clicks on an item and thus selects it directly.\n * Pass as the only argument to \"setCurrentItem\" the item that becomes current (must be one of the items, returned by \"getItemsCallback\").\n *\n * @class\n * @public\n */\nclass ItemNavigation {\n\trootWebComponent: UI5Element;\n\n\t_getItems: () => Array<ITabbable>;\n\n\t_currentIndex: number;\n\n\t_rowSize: number;\n\n\t_behavior: ItemNavigationBehavior;\n\n\t_navigationMode: NavigationMode;\n\n\t_affectedPropertiesNames: Array<string>;\n\n\t_skipItemsSize: number | null;\n\n\t_initBound: () => void;\n\n\t/**\n\t *\n\t * @param rootWebComponent the component to operate on (component that slots or contains within its shadow root the items the user navigates among)\n\t * @param {ItemNavigationOptions} options Object with configuration options:\n\t *  - currentIndex: the index of the item that will be initially selected (from which navigation will begin)\n\t *  - navigationMode (Auto|Horizontal|Vertical): whether the items are displayed horizontally (Horizontal), vertically (Vertical) or as a matrix (Auto) meaning the user can navigate in both directions (up/down and left/right)\n\t *  - rowSize: tells how many items per row there are when the items are not rendered as a flat list but rather as a matrix. Relevant for navigationMode=Auto\n\t * \t- skipItemsSize: tells how many items upon PAGE_UP and PAGE_DOWN should be skipped to applying the focus on the next item\n\t *  - behavior (Static|Cycling): tells what to do when trying to navigate beyond the first and last items\n\t *    Static means that nothing happens if the user tries to navigate beyond the first/last item.\n\t *    Cycling means that when the user navigates beyond the last item they go to the first and vice versa.\n\t *  - getItemsCallback: function that, when called, returns an array with all items the user can navigate among\n\t *  - affectedPropertiesNames: a list of metadata properties on the root component which, upon user navigation, will be reassigned by address thus causing the root component to invalidate\n\t */\n\tconstructor(rootWebComponent: UI5Element, options: ItemNavigationOptions) {\n\t\tif (!rootWebComponent.isUI5Element) {\n\t\t\tthrow new Error(\"The root web component must be a UI5 Element instance\");\n\t\t}\n\n\t\tthis.rootWebComponent = rootWebComponent;\n\t\tthis.rootWebComponent.addEventListener(\"keydown\", this._onkeydown.bind(this));\n\t\tthis._initBound = this._init.bind(this);\n\t\tthis.rootWebComponent.attachComponentStateFinalized(this._initBound);\n\n\t\tif (typeof options.getItemsCallback !== \"function\") {\n\t\t\tthrow new Error(\"getItemsCallback is required\");\n\t\t}\n\n\t\tthis._getItems = options.getItemsCallback;\n\t\tthis._currentIndex = options.currentIndex || 0;\n\t\tthis._rowSize = options.rowSize || 1;\n\t\tthis._behavior = options.behavior || ItemNavigationBehavior.Static;\n\t\tthis._navigationMode = options.navigationMode || NavigationMode.Auto;\n\t\tthis._affectedPropertiesNames = options.affectedPropertiesNames || [];\n\t\tthis._skipItemsSize = options.skipItemsSize || null;\n\t}\n\n\t/**\n\t * Call this method to set a new \"current\" (selected) item in the item navigation\n\t * Note: the item passed to this function must be one of the items, returned by the getItemsCallback function\n\t *\n\t * @public\n\t * @param current the new selected item\n\t */\n\tsetCurrentItem(current: ITabbable): void {\n\t\tconst currentItemIndex = this._getItems().indexOf(current);\n\n\t\tif (currentItemIndex === -1) {\n\t\t\tconsole.warn(`The provided item is not managed by ItemNavigation`, current); // eslint-disable-line\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentIndex = currentItemIndex;\n\t\tthis._applyTabIndex();\n\t}\n\n\t/**\n\t * Call this method to dynamically change the row size\n\t *\n\t * @public\n\t * @param newRowSize\n\t */\n\tsetRowSize(newRowSize: number): void {\n\t\tthis._rowSize = newRowSize;\n\t}\n\n\t_init() {\n\t\tthis._getItems().forEach((item, idx) => {\n\t\t\titem.forcedTabIndex = (idx === this._currentIndex) ? \"0\" : \"-1\";\n\t\t});\n\t}\n\n\t_onkeydown(event: KeyboardEvent) {\n\t\tif (!this._canNavigate()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst horizontalNavigationOn = this._navigationMode === NavigationMode.Horizontal || this._navigationMode === NavigationMode.Auto;\n\t\tconst verticalNavigationOn = this._navigationMode === NavigationMode.Vertical || this._navigationMode === NavigationMode.Auto;\n\t\tconst isRTL = this.rootWebComponent.effectiveDir === \"rtl\";\n\n\t\tif (isRTL && isLeft(event) && horizontalNavigationOn) {\n\t\t\tthis._handleRight();\n\t\t} else if (isRTL && isRight(event) && horizontalNavigationOn) {\n\t\t\tthis._handleLeft();\n\t\t} else if (isLeft(event) && horizontalNavigationOn) {\n\t\t\tthis._handleLeft();\n\t\t} else if (isRight(event) && horizontalNavigationOn) {\n\t\t\tthis._handleRight();\n\t\t} else if (isUp(event) && verticalNavigationOn) {\n\t\t\tthis._handleUp();\n\t\t} else if (isDown(event) && verticalNavigationOn) {\n\t\t\tthis._handleDown();\n\t\t} else if (isHome(event)) {\n\t\t\tthis._handleHome();\n\t\t} else if (isEnd(event)) {\n\t\t\tthis._handleEnd();\n\t\t} else if (isPageUp(event)) {\n\t\t\tthis._handlePageUp();\n\t\t} else if (isPageDown(event)) {\n\t\t\tthis._handlePageDown();\n\t\t} else {\n\t\t\treturn; // if none of the supported keys is pressed, we don't want to prevent the event or update the item navigation\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tthis._applyTabIndex();\n\t\tthis._focusCurrentItem();\n\t}\n\n\t_handleUp() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex - this._rowSize >= 0) { // no border reached, just decrease the index by a row\n\t\t\tthis._currentIndex -= this._rowSize;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // if cyclic, go to the **last** item in the **previous** column\n\t\t\tconst firstItemInThisColumnIndex = this._currentIndex % this._rowSize;\n\t\t\tconst firstItemInPreviousColumnIndex = firstItemInThisColumnIndex === 0 ? this._rowSize - 1 : firstItemInThisColumnIndex - 1; // find the first item in the previous column (if the current column is the first column -> move to the last column)\n\t\t\tconst rows = Math.ceil(itemsLength / this._rowSize); // how many rows there are (even if incomplete, f.e. for 14 items and _rowSize=4 -> 4 rows total, although only 2 items on the last row)\n\t\t\tlet lastItemInPreviousColumnIndex = firstItemInPreviousColumnIndex + (rows - 1) * this._rowSize; // multiply rows by columns, and add the column's first item's index\n\t\t\tif (lastItemInPreviousColumnIndex > itemsLength - 1) { // for incomplete rows, use the previous row's last item, as for them the last item is missing\n\t\t\t\tlastItemInPreviousColumnIndex -= this._rowSize;\n\t\t\t}\n\t\t\tthis._currentIndex = lastItemInPreviousColumnIndex;\n\t\t} else { // not cyclic, so just go to the first item\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\t}\n\n\t_handleDown() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex + this._rowSize < itemsLength) { // no border reached, just increase the index by a row\n\t\t\tthis._currentIndex += this._rowSize;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // if cyclic, go to the **first** item in the **next** column\n\t\t\tconst firstItemInThisColumnIndex = this._currentIndex % this._rowSize; // find the first item in the current column first\n\t\t\tconst firstItemInNextColumnIndex = (firstItemInThisColumnIndex + 1) % this._rowSize; // to get the first item in the next column, just increase the index by 1. The modulo by rows is for the case when we are at the last column\n\t\t\tthis._currentIndex = firstItemInNextColumnIndex;\n\t\t} else { // not cyclic, so just go to the last item\n\t\t\tthis._currentIndex = itemsLength - 1;\n\t\t}\n\t}\n\n\t_handleLeft() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex > 0) {\n\t\t\tthis._currentIndex -= 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // go to the first item in the next column\n\t\t\tthis._currentIndex = itemsLength - 1;\n\t\t}\n\t}\n\n\t_handleRight() {\n\t\tconst itemsLength = this._getItems().length;\n\t\tif (this._currentIndex < itemsLength - 1) {\n\t\t\tthis._currentIndex += 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._behavior === ItemNavigationBehavior.Cyclic) { // go to the first item in the next column\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\t}\n\n\t_handleHome() {\n\t\tconst homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n\t\tthis._currentIndex -= this._currentIndex % homeEndRange;\n\t}\n\n\t_handleEnd() {\n\t\tconst homeEndRange = this._rowSize > 1 ? this._rowSize : this._getItems().length;\n\t\tthis._currentIndex += (homeEndRange - 1 - this._currentIndex % homeEndRange); // eslint-disable-line\n\t}\n\n\t_handlePageUp() {\n\t\tif (this._rowSize > 1) {\n\t\t\t// eslint-disable-next-line\n\t\t\t// TODO: handle page up on matrix (grid) layout - ColorPalette, ProductSwitch.\n\t\t\treturn;\n\t\t}\n\t\tthis._handlePageUpFlat();\n\t}\n\n\t_handlePageDown() {\n\t\tif (this._rowSize > 1) {\n\t\t\t// eslint-disable-next-line\n\t\t\t// TODO: handle page up on matrix (grid) layout - ColorPalette, ProductSwitch.\n\t\t\treturn;\n\t\t}\n\t\tthis._handlePageDownFlat();\n\t}\n\n\t/**\n\t * Handles PAGE_UP in a flat list-like structure, both vertically and horizontally.\n\t */\n\t_handlePageUpFlat() {\n\t\tif (this._skipItemsSize === null) {\n\t\t\t// Move the focus to the very top (as Home).\n\t\t\tthis._currentIndex -= this._currentIndex;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._currentIndex + 1 > this._skipItemsSize) {\n\t\t\t// When there are more than \"skipItemsSize\" number of items to the top,\n\t\t\t// move the focus up/left with the predefined number.\n\t\t\tthis._currentIndex -= this._skipItemsSize;\n\t\t} else {\n\t\t\t// Otherwise, move the focus to the very top (as Home).\n\t\t\tthis._currentIndex -= this._currentIndex;\n\t\t}\n\t}\n\n\t/**\n\t * Handles PAGE_DOWN in a flat list-like structure, both vertically and horizontally.\n\t */\n\t_handlePageDownFlat() {\n\t\tif (this._skipItemsSize === null) {\n\t\t\t// Move the focus to the very bottom (as End).\n\t\t\tthis._currentIndex = this._getItems().length - 1;\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentToEndRange = this._getItems().length - this._currentIndex - 1;\n\n\t\tif (currentToEndRange > this._skipItemsSize) {\n\t\t\t// When there are more than \"skipItemsSize\" number of items until the bottom,\n\t\t\t// move the focus down/right with the predefined number.\n\t\t\tthis._currentIndex += this._skipItemsSize;\n\t\t} else {\n\t\t\t// Otherwise, move the focus to the very bottom (as End).\n\t\t\tthis._currentIndex = this._getItems().length - 1;\n\t\t}\n\t}\n\n\t_applyTabIndex() {\n\t\tconst items = this._getItems();\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\titems[i].forcedTabIndex = i === this._currentIndex ? \"0\" : \"-1\";\n\t\t}\n\n\t\tthis._affectedPropertiesNames.forEach(propName => {\n\t\t\tconst prop = (this.rootWebComponent as Record<string, any>)[propName];\n\t\t\t(this.rootWebComponent as Record<string, any>)[propName] = Array.isArray(prop) ? [...prop] : { ...prop };\n\t\t});\n\t}\n\n\t_focusCurrentItem() {\n\t\tconst currentItem = this._getCurrentItem();\n\t\tif (currentItem) {\n\t\t\tcurrentItem.focus();\n\t\t}\n\t}\n\n\t_canNavigate() {\n\t\tconst currentItem = this._getCurrentItem();\n\t\tconst activeElement = getActiveElement();\n\n\t\treturn currentItem && currentItem === activeElement;\n\t}\n\n\t_getCurrentItem() {\n\t\tconst items = this._getItems();\n\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\n\t\t// normalize the index\n\t\twhile (this._currentIndex >= items.length) {\n\t\t\tthis._currentIndex -= this._rowSize;\n\t\t}\n\n\t\tif (this._currentIndex < 0) {\n\t\t\tthis._currentIndex = 0;\n\t\t}\n\n\t\tconst currentItem = items[this._currentIndex];\n\n\t\tif (!currentItem) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (instanceOfUI5Element(currentItem)) {\n\t\t\treturn currentItem.getFocusDomRef();\n\t\t}\n\n\t\tconst currentItemDOMRef = this.rootWebComponent.getDomRef();\n\t\tif (!currentItemDOMRef) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (currentItem.id) {\n\t\t\treturn currentItemDOMRef.querySelector(`[id=\"${currentItem.id}\"]`) as HTMLElement;\n\t\t}\n\t}\n}\n\nexport default ItemNavigation;\n\nexport {\n\tITabbable,\n};\n"],
  "mappings": "aAAA,OACC,UAAAA,EACA,QAAAC,EACA,UAAAC,EACA,WAAAC,EACA,UAAAC,EACA,SAAAC,EACA,cAAAC,EACA,YAAAC,MACM,aACP,OAAOC,MAAsB,8BAE7B,OAAOC,MAAoB,6BAC3B,OAAOC,MAA4B,qCAGnC,OAAS,wBAAAC,MAA4B,mBAkDrC,MAAMC,CAAe,CAiCpB,YAAYC,EAA8BC,EAAgC,CACzE,GAAI,CAACD,EAAiB,aACrB,MAAM,IAAI,MAAM,uDAAuD,EAQxE,GALA,KAAK,iBAAmBA,EACxB,KAAK,iBAAiB,iBAAiB,UAAW,KAAK,WAAW,KAAK,IAAI,CAAC,EAC5E,KAAK,WAAa,KAAK,MAAM,KAAK,IAAI,EACtC,KAAK,iBAAiB,8BAA8B,KAAK,UAAU,EAE/D,OAAOC,EAAQ,kBAAqB,WACvC,MAAM,IAAI,MAAM,8BAA8B,EAG/C,KAAK,UAAYA,EAAQ,iBACzB,KAAK,cAAgBA,EAAQ,cAAgB,EAC7C,KAAK,SAAWA,EAAQ,SAAW,EACnC,KAAK,UAAYA,EAAQ,UAAYJ,EAAuB,OAC5D,KAAK,gBAAkBI,EAAQ,gBAAkBL,EAAe,KAChE,KAAK,yBAA2BK,EAAQ,yBAA2B,CAAC,EACpE,KAAK,eAAiBA,EAAQ,eAAiB,IAChD,CASA,eAAeC,EAA0B,CACxC,MAAMC,EAAmB,KAAK,UAAU,EAAE,QAAQD,CAAO,EAEzD,GAAIC,IAAqB,GAAI,CAC5B,QAAQ,KAAK,qDAAsDD,CAAO,EAC1E,MACD,CAEA,KAAK,cAAgBC,EACrB,KAAK,eAAe,CACrB,CAQA,WAAWC,EAA0B,CACpC,KAAK,SAAWA,CACjB,CAEA,OAAQ,CACP,KAAK,UAAU,EAAE,QAAQ,CAACC,EAAMC,IAAQ,CACvCD,EAAK,eAAkBC,IAAQ,KAAK,cAAiB,IAAM,IAC5D,CAAC,CACF,CAEA,WAAWC,EAAsB,CAChC,GAAI,CAAC,KAAK,aAAa,EACtB,OAGD,MAAMC,EAAyB,KAAK,kBAAoBZ,EAAe,YAAc,KAAK,kBAAoBA,EAAe,KACvHa,EAAuB,KAAK,kBAAoBb,EAAe,UAAY,KAAK,kBAAoBA,EAAe,KACnHc,EAAQ,KAAK,iBAAiB,eAAiB,MAErD,GAAIA,GAASrB,EAAOkB,CAAK,GAAKC,EAC7B,KAAK,aAAa,UACRE,GAASpB,EAAQiB,CAAK,GAAKC,EACrC,KAAK,YAAY,UACPnB,EAAOkB,CAAK,GAAKC,EAC3B,KAAK,YAAY,UACPlB,EAAQiB,CAAK,GAAKC,EAC5B,KAAK,aAAa,UACRpB,EAAKmB,CAAK,GAAKE,EACzB,KAAK,UAAU,UACLtB,EAAOoB,CAAK,GAAKE,EAC3B,KAAK,YAAY,UACPlB,EAAOgB,CAAK,EACtB,KAAK,YAAY,UACPf,EAAMe,CAAK,EACrB,KAAK,WAAW,UACNb,EAASa,CAAK,EACxB,KAAK,cAAc,UACTd,EAAWc,CAAK,EAC1B,KAAK,gBAAgB,MAErB,QAGDA,EAAM,eAAe,EACrB,KAAK,eAAe,EACpB,KAAK,kBAAkB,CACxB,CAEA,WAAY,CACX,MAAMI,EAAc,KAAK,UAAU,EAAE,OACrC,GAAI,KAAK,cAAgB,KAAK,UAAY,EAAG,CAC5C,KAAK,eAAiB,KAAK,SAC3B,MACD,CAEA,GAAI,KAAK,YAAcd,EAAuB,OAAQ,CACrD,MAAMe,EAA6B,KAAK,cAAgB,KAAK,SACvDC,EAAiCD,IAA+B,EAAI,KAAK,SAAW,EAAIA,EAA6B,EACrHE,EAAO,KAAK,KAAKH,EAAc,KAAK,QAAQ,EAClD,IAAII,EAAgCF,GAAkCC,EAAO,GAAK,KAAK,SACnFC,EAAgCJ,EAAc,IACjDI,GAAiC,KAAK,UAEvC,KAAK,cAAgBA,CACtB,MACC,KAAK,cAAgB,CAEvB,CAEA,aAAc,CACb,MAAMJ,EAAc,KAAK,UAAU,EAAE,OACrC,GAAI,KAAK,cAAgB,KAAK,SAAWA,EAAa,CACrD,KAAK,eAAiB,KAAK,SAC3B,MACD,CAEA,GAAI,KAAK,YAAcd,EAAuB,OAAQ,CAErD,MAAMmB,GAD6B,KAAK,cAAgB,KAAK,SACI,GAAK,KAAK,SAC3E,KAAK,cAAgBA,CACtB,MACC,KAAK,cAAgBL,EAAc,CAErC,CAEA,aAAc,CACb,MAAMA,EAAc,KAAK,UAAU,EAAE,OACrC,GAAI,KAAK,cAAgB,EAAG,CAC3B,KAAK,eAAiB,EACtB,MACD,CAEI,KAAK,YAAcd,EAAuB,SAC7C,KAAK,cAAgBc,EAAc,EAErC,CAEA,cAAe,CACd,MAAMA,EAAc,KAAK,UAAU,EAAE,OACrC,GAAI,KAAK,cAAgBA,EAAc,EAAG,CACzC,KAAK,eAAiB,EACtB,MACD,CAEI,KAAK,YAAcd,EAAuB,SAC7C,KAAK,cAAgB,EAEvB,CAEA,aAAc,CACb,MAAMoB,EAAe,KAAK,SAAW,EAAI,KAAK,SAAW,KAAK,UAAU,EAAE,OAC1E,KAAK,eAAiB,KAAK,cAAgBA,CAC5C,CAEA,YAAa,CACZ,MAAMA,EAAe,KAAK,SAAW,EAAI,KAAK,SAAW,KAAK,UAAU,EAAE,OAC1E,KAAK,eAAkBA,EAAe,EAAI,KAAK,cAAgBA,CAChE,CAEA,eAAgB,CACX,KAAK,SAAW,GAKpB,KAAK,kBAAkB,CACxB,CAEA,iBAAkB,CACb,KAAK,SAAW,GAKpB,KAAK,oBAAoB,CAC1B,CAKA,mBAAoB,CACnB,GAAI,KAAK,iBAAmB,KAAM,CAEjC,KAAK,eAAiB,KAAK,cAC3B,MACD,CAEI,KAAK,cAAgB,EAAI,KAAK,eAGjC,KAAK,eAAiB,KAAK,eAG3B,KAAK,eAAiB,KAAK,aAE7B,CAKA,qBAAsB,CACrB,GAAI,KAAK,iBAAmB,KAAM,CAEjC,KAAK,cAAgB,KAAK,UAAU,EAAE,OAAS,EAC/C,MACD,CAE0B,KAAK,UAAU,EAAE,OAAS,KAAK,cAAgB,EAEjD,KAAK,eAG5B,KAAK,eAAiB,KAAK,eAG3B,KAAK,cAAgB,KAAK,UAAU,EAAE,OAAS,CAEjD,CAEA,gBAAiB,CAChB,MAAMC,EAAQ,KAAK,UAAU,EAC7B,QAASC,EAAI,EAAGA,EAAID,EAAM,OAAQC,IACjCD,EAAMC,CAAC,EAAE,eAAiBA,IAAM,KAAK,cAAgB,IAAM,KAG5D,KAAK,yBAAyB,QAAQC,GAAY,CACjD,MAAMC,EAAQ,KAAK,iBAAyCD,CAAQ,EACnE,KAAK,iBAAyCA,CAAQ,EAAI,MAAM,QAAQC,CAAI,EAAI,CAAC,GAAGA,CAAI,EAAI,CAAE,GAAGA,CAAK,CACxG,CAAC,CACF,CAEA,mBAAoB,CACnB,MAAMC,EAAc,KAAK,gBAAgB,EACrCA,GACHA,EAAY,MAAM,CAEpB,CAEA,cAAe,CACd,MAAMA,EAAc,KAAK,gBAAgB,EACnCC,EAAgB5B,EAAiB,EAEvC,OAAO2B,GAAeA,IAAgBC,CACvC,CAEA,iBAAkB,CACjB,MAAML,EAAQ,KAAK,UAAU,EAE7B,GAAI,CAACA,EAAM,OACV,OAID,KAAO,KAAK,eAAiBA,EAAM,QAClC,KAAK,eAAiB,KAAK,SAGxB,KAAK,cAAgB,IACxB,KAAK,cAAgB,GAGtB,MAAMI,EAAcJ,EAAM,KAAK,aAAa,EAE5C,GAAI,CAACI,EACJ,OAGD,GAAIxB,EAAqBwB,CAAW,EACnC,OAAOA,EAAY,eAAe,EAGnC,MAAME,EAAoB,KAAK,iBAAiB,UAAU,EAC1D,GAAKA,GAIDF,EAAY,GACf,OAAOE,EAAkB,cAAc,QAAQF,EAAY,EAAE,IAAI,CAEnE,CACD,CAEA,eAAevB,EAEf",
  "names": ["isDown", "isUp", "isLeft", "isRight", "isHome", "isEnd", "isPageDown", "isPageUp", "getActiveElement", "NavigationMode", "ItemNavigationBehavior", "instanceOfUI5Element", "ItemNavigation", "rootWebComponent", "options", "current", "currentItemIndex", "newRowSize", "item", "idx", "event", "horizontalNavigationOn", "verticalNavigationOn", "isRTL", "itemsLength", "firstItemInThisColumnIndex", "firstItemInPreviousColumnIndex", "rows", "lastItemInPreviousColumnIndex", "firstItemInNextColumnIndex", "homeEndRange", "items", "i", "propName", "prop", "currentItem", "activeElement", "currentItemDOMRef"]
}
