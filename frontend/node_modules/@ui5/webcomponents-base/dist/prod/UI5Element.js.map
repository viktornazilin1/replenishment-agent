{
  "version": 3,
  "sources": ["../../src/UI5Element.ts"],
  "sourcesContent": ["// eslint-disable-next-line import/no-extraneous-dependencies\nimport \"@ui5/webcomponents-base/dist/ssr-dom.js\";\nimport type { JSX } from \"./jsx-runtime.js\";\nimport merge from \"./thirdparty/merge.js\";\nimport { boot } from \"./Boot.js\";\nimport UI5ElementMetadata from \"./UI5ElementMetadata.js\";\nimport type {\n\tSlot,\n\tSlotValue,\n\tState,\n\tPropertyValue,\n\tMetadata,\n} from \"./UI5ElementMetadata.js\";\nimport EventProvider from \"./EventProvider.js\";\nimport updateShadowRoot from \"./updateShadowRoot.js\";\nimport { shouldIgnoreCustomElement } from \"./IgnoreCustomElements.js\";\nimport {\n\trenderDeferred,\n\trenderImmediately,\n\tcancelRender,\n} from \"./Render.js\";\nimport { registerTag, isTagRegistered, recordTagRegistrationFailure } from \"./CustomElementsRegistry.js\";\nimport { observeDOMNode, unobserveDOMNode } from \"./DOMObserver.js\";\nimport { skipOriginalEvent } from \"./config/NoConflict.js\";\nimport getEffectiveDir from \"./locale/getEffectiveDir.js\";\nimport { kebabToCamelCase, camelToKebabCase, kebabToPascalCase } from \"./util/StringHelper.js\";\nimport isValidPropertyName from \"./util/isValidPropertyName.js\";\nimport { getSlotName, getSlottedNodesList } from \"./util/SlotsHelper.js\";\nimport arraysAreEqual from \"./util/arraysAreEqual.js\";\nimport { markAsRtlAware } from \"./locale/RTLAwareRegistry.js\";\nimport executeTemplate from \"./renderer/executeTemplate.js\";\nimport { shouldScopeCustomElement } from \"./CustomElementsScopeUtils.js\";\nimport type { TemplateFunction } from \"./renderer/executeTemplate.js\";\nimport type {\n\tAccessibilityInfo,\n\tPromiseResolve,\n\tComponentStylesData,\n\tClassMap,\n} from \"./types.js\";\nimport { updateFormValue, setFormValue } from \"./features/InputElementsFormSupport.js\";\nimport type { IFormInputElement } from \"./features/InputElementsFormSupport.js\";\nimport { getI18nBundle } from \"./i18nBundle.js\";\nimport type I18nBundle from \"./i18nBundle.js\";\nimport { fetchCldr } from \"./asset-registries/LocaleData.js\";\nimport getLocale from \"./locale/getLocale.js\";\n\n;\nlet autoId = 0;\n\nconst elementTimeouts = new Map<string, Promise<void>>();\nconst uniqueDependenciesCache = new Map<typeof UI5Element, Array<typeof UI5Element>>();\n\ntype Renderer = (instance: UI5Element, container: HTMLElement | DocumentFragment) => void;\n\ntype ChangeInfo = {\n\ttype: \"property\" | \"slot\",\n\tname: string,\n\treason?: string,\n\tchild?: SlotValue,\n\ttarget?: UI5Element,\n\tnewValue?: PropertyValue,\n\toldValue?: PropertyValue,\n}\n\ntype InvalidationInfo = ChangeInfo & { target: UI5Element };\n\ntype ChildChangeListener = (param: InvalidationInfo) => void;\n\ntype SlotChangeListener = (this: HTMLSlotElement, ev: Event) => void;\n\ntype SlottedChild = Record<string, any>;\n\nconst defaultConverter = {\n\tfromAttribute(value: string | null, type: unknown) {\n\t\tif (type === Boolean) {\n\t\t\treturn value !== null;\n\t\t}\n\t\tif (type === Number) {\n\t\t\treturn value === null ? undefined : parseFloat(value);\n\t\t}\n\t\treturn value;\n\t},\n\ttoAttribute(value: unknown, type: unknown) {\n\t\tif (type === Boolean) {\n\t\t\treturn value as boolean ? \"\" : null;\n\t\t}\n\n\t\t// don't set attributes for arrays and objects\n\t\tif (type === Object || type === Array) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// object, array, other\n\t\tif (value === null || value === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn String(value);\n\t},\n};\n\n/**\n * Triggers re-rendering of a UI5Element instance due to state change.\n * @param {ChangeInfo} changeInfo An object with information about the change that caused invalidation.\n * @private\n */\nfunction _invalidate(this: UI5Element, changeInfo: ChangeInfo) {\n\t// Invalidation should be suppressed: 1) before the component is rendered for the first time 2) and during the execution of onBeforeRendering\n\t// This is necessary not only as an optimization, but also to avoid infinite loops on invalidation between children and parents (when invalidateOnChildChange is used)\n\tif (this._suppressInvalidation) {\n\t\treturn;\n\t}\n\n\t// Call the onInvalidation hook\n\tthis.onInvalidation(changeInfo);\n\n\tthis._changedState.push(changeInfo);\n\trenderDeferred(this);\n\tthis._invalidationEventProvider.fireEvent(\"invalidate\", { ...changeInfo, target: this });\n}\n\n/**\n * looks up a property descsriptor including in the prototype chain\n * @param proto the starting prototype\n * @param name the property to look for\n * @returns the property descriptor if found directly or in the prototype chaing, undefined if not found\n */\nfunction getPropertyDescriptor(proto: any, name: PropertyKey): PropertyDescriptor | undefined {\n\tdo {\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(proto, name);\n\t\tif (descriptor) {\n\t\t\treturn descriptor;\n\t\t}\n\t\t// go up the prototype chain\n\t\tproto = Object.getPrototypeOf(proto);\n\t} while (proto && proto !== HTMLElement.prototype);\n}\n\ntype NotEqual<X, Y> = true extends Equal<X, Y> ? false : true\ntype Equal<X, Y> =\n  (<T>() => T extends X ? 1 : 2) extends\n  (<T>() => T extends Y ? 1 : 2) ? true : false\n\n// JSX support\ntype IsAny<T, Y, N> = 0 extends (1 & T) ? Y : N\n// type Convert<T> = { [Property in keyof T as `on${KebabToPascal<string & Property>}` ]: T[Property] extends IsAny<T> ? any : (e: CustomEvent<T[Property]>) => void }\ntype KebabToCamel<T extends string> = T extends `${infer H}-${infer J}${infer K}`\n? `${Uncapitalize<H>}${Capitalize<J>}${KebabToCamel<K>}`\n: T;\ntype KebabToPascal<T extends string> = Capitalize<KebabToCamel<T>>;\n\ntype GlobalHTMLAttributeNames = \"accesskey\" | \"autocapitalize\" | \"autofocus\" | \"autocomplete\" | \"contenteditable\" | \"contextmenu\" | \"class\" | \"dir\" | \"draggable\" | \"enterkeyhint\" | \"hidden\" | \"id\" | \"inputmode\" | \"lang\" | \"nonce\" | \"part\" | \"exportparts\" | \"pattern\" | \"slot\" | \"spellcheck\" | \"style\" | \"tabIndex\" | \"tabindex\" | \"title\" | \"translate\" | \"ref\" | \"inert\";\ntype ElementProps<I> = Partial<Omit<I, keyof HTMLElement>>;\ntype TargetedCustomEvent<D, T> = Omit<CustomEvent<D>, \"currentTarget\"> & { currentTarget: T };\n// define as method and extract the function signature from the method to make it bivariant so that inheritance of event handlers is not checked via strictFunctionTypes\n// https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#strict-function-types\ntype TargetedEventHandler<D, T> = {\n\tasMethod(e: TargetedCustomEvent<D, T>): void\n}[\"asMethod\"];\ntype Convert<T, K extends UI5Element> = { [Property in keyof T as `on${KebabToPascal<string & Property>}` ]: IsAny<T[Property], any, TargetedEventHandler<T[Property], K>> }\n\n/**\n * @class\n * Base class for all UI5 Web Components\n *\n * @extends HTMLElement\n * @public\n */\nabstract class UI5Element extends HTMLElement {\n\teventDetails!: NotEqual<this, UI5Element> extends true ? object : {\n\t\t[k: string]: any\n\t};\n\t_jsxEvents!: Omit<JSX.DOMAttributes<this>, keyof Convert<this[\"eventDetails\"], this> | \"onClose\" | \"onToggle\" | \"onChange\" | \"onSelect\" | \"onInput\"> & Convert<this[\"eventDetails\"], this>\n\t_jsxProps!: Pick<JSX.AllHTMLAttributes<HTMLElement>, GlobalHTMLAttributeNames> & ElementProps<this> & Partial<this[\"_jsxEvents\"]> & { key?: any };\n\t__id?: string;\n\t_suppressInvalidation: boolean;\n\t_changedState: Array<ChangeInfo>;\n\t_invalidationEventProvider: EventProvider<InvalidationInfo, void>;\n\t_componentStateFinalizedEventProvider: EventProvider<void, void>;\n\t_inDOM: boolean;\n\t_fullyConnected: boolean;\n\t_childChangeListeners: Map<string, ChildChangeListener>;\n\t_slotsAssignedNodes: WeakMap<HTMLSlotElement, Array<SlotValue>>;\n\t_slotChangeListeners: Map<string, SlotChangeListener>;\n\t_domRefReadyPromise: Promise<void> & { _deferredResolve?: PromiseResolve };\n\t_doNotSyncAttributes: Set<string>;\n\t_state: State;\n\t_internals: ElementInternals;\n\t_individualSlot?: string;\n\t_getRealDomRef?: () => HTMLElement;\n\n\tstatic template?: TemplateFunction;\n\tstatic _metadata: UI5ElementMetadata;\n\n\tstatic renderer: Renderer;\n\tinitializedProperties: Map<string, unknown>;\n\n\t// used to differentiate whether a setter is called from the constructor (from an initializer) or later\n\t// setters from the constructor should not set attributes, this is delegated after the first rendering but is async\n\t// setters after the constructor can set attributes synchronously for more convinient development\n\t_rendered = false;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tthis._changedState = []; // Filled on each invalidation, cleared on re-render (used for debugging)\n\t\tthis._suppressInvalidation = true; // A flag telling whether all invalidations should be ignored. Initialized with \"true\" because a UI5Element can not be invalidated until it is rendered for the first time\n\t\tthis._inDOM = false; // A flag telling whether the UI5Element is currently in the DOM tree of the document or not\n\t\tthis._fullyConnected = false; // A flag telling whether the UI5Element's onEnterDOM hook was called (since it's possible to have the element removed from DOM before that)\n\t\tthis._childChangeListeners = new Map(); // used to store lazy listeners per slot for the child change event of every child inside that slot\n\t\tthis._slotChangeListeners = new Map(); // used to store lazy listeners per slot for the slotchange event of all slot children inside that slot\n\t\tthis._invalidationEventProvider = new EventProvider(); // used by parent components for listening to changes to child components\n\t\tthis._componentStateFinalizedEventProvider = new EventProvider(); // used by friend classes for synchronization\n\t\tlet deferredResolve;\n\t\tthis._domRefReadyPromise = new Promise(resolve => {\n\t\t\tdeferredResolve = resolve;\n\t\t});\n\t\tthis._domRefReadyPromise._deferredResolve = deferredResolve;\n\t\tthis._doNotSyncAttributes = new Set(); // attributes that are excluded from attributeChangedCallback synchronization\n\t\tthis._slotsAssignedNodes = new WeakMap(); // map of all nodes, slotted (directly or transitively) per component slot\n\n\t\tthis._state = { ...ctor.getMetadata().getInitialState() };\n\n\t\t// save properties set before element is upgraded, as they will be overriden by the field initializers in the constructor\n\t\tthis.initializedProperties = new Map();\n\t\tconst allProps = (this.constructor as typeof UI5Element).getMetadata().getPropertiesList();\n\t\tallProps.forEach(propertyName => {\n\t\t\tif (this.hasOwnProperty(propertyName)) { // eslint-disable-line\n\t\t\t\tconst value = (this as Record<string, unknown>)[propertyName];\n\t\t\t\tthis.initializedProperties.set(propertyName, value);\n\t\t\t}\n\t\t});\n\t\tthis._internals = this.attachInternals();\n\n\t\tthis._initShadowRoot();\n\t}\n\n\t_initShadowRoot() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tif (ctor._needsShadowDOM()) {\n\t\t\tconst defaultOptions = { mode: \"open\" } as ShadowRootInit;\n\t\t\tthis.attachShadow({ ...defaultOptions, ...ctor.getMetadata().getShadowRootOptions() });\n\n\t\t\tconst slotsAreManaged = ctor.getMetadata().slotsAreManaged();\n\t\t\tif (slotsAreManaged) {\n\t\t\t\tthis.shadowRoot!.addEventListener(\"slotchange\", this._onShadowRootSlotChange.bind(this));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Note: this \"slotchange\" listener is for slots, rendered in the component's shadow root\n\t */\n\t_onShadowRootSlotChange(e: Event) {\n\t\tconst targetShadowRoot = (e.target as Node)?.getRootNode(); // the \"slotchange\" event target is always a slot element\n\t\tif (targetShadowRoot === this.shadowRoot) { // only for slotchange events that originate from slots, belonging to the component's shadow root\n\t\t\tthis._processChildren();\n\t\t}\n\t}\n\n\t/**\n\t * Returns a unique ID for this UI5 Element\n\t *\n\t * @deprecated - This property is not guaranteed in future releases\n\t * @protected\n\t */\n\tget _id() {\n\t\tif (!this.__id) {\n\t\t\tthis.__id = `ui5wc_${++autoId}`;\n\t\t}\n\n\t\treturn this.__id;\n\t}\n\n\trender() {\n\t\tconst template = (this.constructor as typeof UI5Element).template;\n\t\treturn executeTemplate(template!, this);\n\t}\n\n\t/**\n\t * Do not call this method from derivatives of UI5Element, use \"onEnterDOM\" only\n\t * @private\n\t */\n\tasync connectedCallback() {\n\t\tif (false) {\n\t\t\tconst props = (this.constructor as typeof UI5Element).getMetadata().getProperties();\n\t\t\tfor (const [prop, propData] of Object.entries(props)) { // eslint-disable-line\n\t\t\t\tif (Object.hasOwn(this, prop) && !this.initializedProperties.has(prop)) {\n\t\t\t\t\t// initialized properties should not trigger this error as they will be reassigned, only property initializers will trigger this in case unsupported TS mode\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.error(`[UI5-FWK] ${(this.constructor as typeof UI5Element).getMetadata().getTag()} has a property [${prop}] that is shadowed by the instance. Updates to this property will not invalidate the component. Possible reason is TS target ES2022 or TS useDefineForClassFields`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\n\t\tthis.setAttribute(ctor.getMetadata().getPureTag(), \"\");\n\t\tif (ctor.getMetadata().supportsF6FastNavigation()) {\n\t\t\tthis.setAttribute(\"data-sap-ui-fastnavgroup\", \"true\");\n\t\t}\n\n\t\tconst slotsAreManaged = ctor.getMetadata().slotsAreManaged();\n\n\t\tthis._inDOM = true;\n\n\t\tif (slotsAreManaged) {\n\t\t\t// always register the observer before yielding control to the main thread (await)\n\t\t\tthis._startObservingDOMChildren();\n\t\t\tawait this._processChildren();\n\t\t}\n\n\t\tif (!this._inDOM) { // Component removed from DOM while _processChildren was running\n\t\t\treturn;\n\t\t}\n\n\t\tif (!ctor.asyncFinished) {\n\t\t\tawait ctor.definePromise;\n\t\t}\n\n\t\trenderImmediately(this);\n\t\tthis._domRefReadyPromise._deferredResolve!();\n\t\tthis._fullyConnected = true;\n\t\tthis.onEnterDOM();\n\t}\n\n\t/**\n\t * Do not call this method from derivatives of UI5Element, use \"onExitDOM\" only\n\t * @private\n\t */\n\tdisconnectedCallback() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst slotsAreManaged = ctor.getMetadata().slotsAreManaged();\n\n\t\tthis._inDOM = false;\n\n\t\tif (slotsAreManaged) {\n\t\t\tthis._stopObservingDOMChildren();\n\t\t}\n\n\t\tif (this._fullyConnected) {\n\t\t\tthis.onExitDOM();\n\t\t\tthis._fullyConnected = false;\n\t\t}\n\n\t\tthis._domRefReadyPromise._deferredResolve!();\n\n\t\tcancelRender(this);\n\t}\n\n\t/**\n\t * Called every time before the component renders.\n\t * @public\n\t */\n\tonBeforeRendering(): void {}\n\n\t/**\n\t * Called every time after the component renders.\n\t * @public\n\t */\n\tonAfterRendering(): void {}\n\n\t/**\n\t * Called on connectedCallback - added to the DOM.\n\t * @public\n\t */\n\tonEnterDOM(): void {}\n\n\t/**\n\t * Called on disconnectedCallback - removed from the DOM.\n\t * @public\n\t */\n\tonExitDOM(): void {}\n\n\t/**\n\t * @private\n\t */\n\t_startObservingDOMChildren() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst metadata = ctor.getMetadata();\n\t\tconst shouldObserveChildren = metadata.hasSlots();\n\n\t\tif (!shouldObserveChildren) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst canSlotText = metadata.canSlotText();\n\t\tconst mutationObserverOptions = {\n\t\t\tchildList: true,\n\t\t\tsubtree: canSlotText,\n\t\t\tcharacterData: canSlotText,\n\t\t};\n\t\tobserveDOMNode(this, this._processChildren.bind(this) as MutationCallback, mutationObserverOptions);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_stopObservingDOMChildren() {\n\t\tunobserveDOMNode(this);\n\t}\n\n\t/**\n\t * Note: this method is also manually called by \"compatibility/patchNodeValue.js\"\n\t * @private\n\t */\n\tasync _processChildren() {\n\t\tconst hasSlots = (this.constructor as typeof UI5Element).getMetadata().hasSlots();\n\t\tif (hasSlots) {\n\t\t\tawait this._updateSlots();\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tasync _updateSlots() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst slotsMap = ctor.getMetadata().getSlots();\n\t\tconst canSlotText = ctor.getMetadata().canSlotText();\n\t\tconst domChildren = Array.from(canSlotText ? this.childNodes : this.children) as Array<Node>;\n\n\t\tconst slotsCachedContentMap = new Map<string, Array<SlotValue>>(); // Store here the content of each slot before the mutation occurred\n\t\tconst propertyNameToSlotMap = new Map<string, string>(); // Used for reverse lookup to determine to which slot the property name corresponds\n\n\t\t// Init the _state object based on the supported slots and store the previous values\n\t\tfor (const [slotName, slotData] of Object.entries(slotsMap)) { // eslint-disable-line\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\tpropertyNameToSlotMap.set(propertyName, slotName);\n\t\t\tslotsCachedContentMap.set(propertyName, [...(this._state[propertyName] as Array<SlotValue>)]);\n\t\t\tthis._clearSlot(slotName, slotData);\n\t\t}\n\n\t\tconst autoIncrementMap = new Map<string, number>();\n\t\tconst slottedChildrenMap = new Map<string, Array<{child: Node, idx: number }>>();\n\n\t\tconst allChildrenUpgraded = domChildren.map(async (child, idx) => {\n\t\t\t// Determine the type of the child (mainly by the slot attribute)\n\t\t\tconst slotName = getSlotName(child);\n\t\t\tconst slotData = slotsMap[slotName];\n\n\t\t\t// Check if the slotName is supported\n\t\t\tif (slotData === undefined) {\n\t\t\t\tif (slotName !== \"default\") {\n\t\t\t\t\tconst validValues = Object.keys(slotsMap).join(\", \");\n\t\t\t\t\tconsole.warn(`Unknown slotName: ${slotName}, ignoring`, child, `Valid values are: ${validValues}`); // eslint-disable-line\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For children that need individual slots, calculate them\n\t\t\tif (slotData.individualSlots) {\n\t\t\t\tconst nextIndex = (autoIncrementMap.get(slotName) || 0) + 1;\n\t\t\t\tautoIncrementMap.set(slotName, nextIndex);\n\t\t\t\t(child as SlottedChild)._individualSlot = `${slotName}-${nextIndex}`;\n\t\t\t}\n\n\t\t\t// Await for not-yet-defined custom elements\n\t\t\tif (child instanceof HTMLElement) {\n\t\t\t\tconst localName = child.localName;\n\t\t\t\tconst shouldWaitForCustomElement = localName.includes(\"-\") && !shouldIgnoreCustomElement(localName);\n\n\t\t\t\tif (shouldWaitForCustomElement) {\n\t\t\t\t\tconst isDefined = customElements.get(localName);\n\t\t\t\t\tif (!isDefined) {\n\t\t\t\t\t\tconst whenDefinedPromise = customElements.whenDefined(localName); // Class registered, but instances not upgraded yet\n\t\t\t\t\t\tlet timeoutPromise = elementTimeouts.get(localName);\n\t\t\t\t\t\tif (!timeoutPromise) {\n\t\t\t\t\t\t\ttimeoutPromise = new Promise(resolve => setTimeout(resolve, 1000));\n\t\t\t\t\t\t\telementTimeouts.set(localName, timeoutPromise);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait Promise.race([whenDefinedPromise, timeoutPromise]);\n\t\t\t\t\t}\n\t\t\t\t\tcustomElements.upgrade(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchild = (ctor.getMetadata().constructor as typeof UI5ElementMetadata).validateSlotValue(child, slotData);\n\n\t\t\t// Listen for any invalidation on the child if invalidateOnChildChange is true or an object (ignore when false or not set)\n\t\t\tif (instanceOfUI5Element(child) && slotData.invalidateOnChildChange) {\n\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\tchild.attachInvalidate.call(child, childChangeListener);\n\t\t\t}\n\n\t\t\t// Listen for the slotchange event if the child is a slot itself\n\t\t\tif (child instanceof HTMLSlotElement) {\n\t\t\t\tthis._attachSlotChange(child, slotName, !!slotData.invalidateOnChildChange);\n\t\t\t}\n\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\n\t\t\tif (slottedChildrenMap.has(propertyName)) {\n\t\t\t\tslottedChildrenMap.get(propertyName)!.push({ child, idx });\n\t\t\t} else {\n\t\t\t\tslottedChildrenMap.set(propertyName, [{ child, idx }]);\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all(allChildrenUpgraded);\n\n\t\t// Distribute the child in the _state object, keeping the Light DOM order,\n\t\t// not the order elements are defined.\n\t\tslottedChildrenMap.forEach((children, propertyName) => {\n\t\t\tthis._state[propertyName] = children.sort((a, b) => a.idx - b.idx).map(_ => _.child);\n\t\t\tthis._state[kebabToCamelCase(propertyName)] = this._state[propertyName];\n\t\t});\n\n\t\t// Compare the content of each slot with the cached values and invalidate for the ones that changed\n\t\tlet invalidated = false;\n\t\tfor (const [slotName, slotData] of Object.entries(slotsMap)) { // eslint-disable-line\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\tif (!arraysAreEqual(slotsCachedContentMap.get(propertyName)!, this._state[propertyName] as Array<SlotValue>)) {\n\t\t\t\t_invalidate.call(this, {\n\t\t\t\t\ttype: \"slot\",\n\t\t\t\t\tname: propertyNameToSlotMap.get(propertyName)!,\n\t\t\t\t\treason: \"children\",\n\t\t\t\t});\n\n\t\t\t\tinvalidated = true;\n\n\t\t\t\tif (ctor.getMetadata().isFormAssociated()) {\n\t\t\t\t\tsetFormValue(this as unknown as IFormInputElement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If none of the slots had an invalidation due to changes to immediate children,\n\t\t// the change is considered to be text content of the default slot\n\t\tif (!invalidated) {\n\t\t\t_invalidate.call(this, {\n\t\t\t\ttype: \"slot\",\n\t\t\t\tname: \"default\",\n\t\t\t\treason: \"textcontent\",\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Removes all children from the slot and detaches listeners, if any\n\t * @private\n\t */\n\t_clearSlot(slotName: string, slotData: Slot) {\n\t\tconst propertyName = slotData.propertyName || slotName;\n\t\tconst children = this._state[propertyName] as Array<SlotValue>;\n\n\t\tchildren.forEach(child => {\n\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\tchild.detachInvalidate.call(child, childChangeListener);\n\t\t\t}\n\n\t\t\tif (child instanceof HTMLSlotElement) {\n\t\t\t\tthis._detachSlotChange(child, slotName);\n\t\t\t}\n\t\t});\n\n\t\tthis._state[propertyName] = [];\n\t\tthis._state[kebabToCamelCase(propertyName)] = this._state[propertyName];\n\t}\n\n\t/**\n\t * Attach a callback that will be executed whenever the component is invalidated\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tattachInvalidate(callback: (param: InvalidationInfo) => void): void {\n\t\tthis._invalidationEventProvider.attachEvent(\"invalidate\", callback);\n\t}\n\n\t/**\n\t * Detach the callback that is executed whenever the component is invalidated\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tdetachInvalidate(callback: (param: InvalidationInfo) => void): void {\n\t\tthis._invalidationEventProvider.detachEvent(\"invalidate\", callback);\n\t}\n\n\t/**\n\t * Callback that is executed whenever a monitored child changes its state\n\t *\n\t * @param slotName the slot in which a child was invalidated\n\t * @param childChangeInfo the changeInfo object for the child in the given slot\n\t * @private\n\t */\n\t_onChildChange(slotName: string, childChangeInfo: ChangeInfo) {\n\t\tif (!(this.constructor as typeof UI5Element).getMetadata().shouldInvalidateOnChildChange(slotName, childChangeInfo.type, childChangeInfo.name)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The component should be invalidated as this type of change on the child is listened for\n\t\t// However, no matter what changed on the child (property/slot), the invalidation is registered as \"type=slot\" for the component itself\n\t\t_invalidate.call(this, {\n\t\t\ttype: \"slot\",\n\t\t\tname: slotName,\n\t\t\treason: \"childchange\",\n\t\t\tchild: childChangeInfo.target,\n\t\t});\n\t}\n\n\t/**\n\t * Do not override this method in derivatives of UI5Element\n\t * @private\n\t */\n\tattributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {\n\t\tlet newPropertyValue: PropertyValue;\n\t\tif (this._doNotSyncAttributes.has(name)) { // This attribute is mutated internally, not by the user\n\t\t\treturn;\n\t\t}\n\n\t\tconst properties = (this.constructor as typeof UI5Element).getMetadata().getProperties();\n\t\tconst realName = name.replace(/^ui5-/, \"\");\n\t\tconst nameInCamelCase = kebabToCamelCase(realName);\n\t\tif (properties.hasOwnProperty(nameInCamelCase)) { // eslint-disable-line\n\t\t\tconst propData = properties[nameInCamelCase];\n\n\t\t\tconst converter = propData.converter ?? defaultConverter;\n\t\t\tnewPropertyValue = converter.fromAttribute(newValue, propData.type);\n\n\t\t\t(this as Record<string, any>)[nameInCamelCase] = newPropertyValue;\n\t\t}\n\t}\n\n\tformAssociatedCallback() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\n\t\tif (!ctor.getMetadata().isFormAssociated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateFormValue(this);\n\t}\n\n\tstatic get formAssociated() {\n\t\treturn this.getMetadata().isFormAssociated();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_updateAttribute(name: string, newValue: PropertyValue) {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\n\t\tif (!ctor.getMetadata().hasAttribute(name)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst properties = ctor.getMetadata().getProperties();\n\t\tconst propData = properties[name];\n\t\tconst attrName = camelToKebabCase(name);\n\t\tconst converter = propData.converter || defaultConverter;\n\n\t\tif (false) {\n\t\t\tconst tag = (this.constructor as typeof UI5Element).getMetadata().getTag();\n\t\t\tif (typeof newValue === \"boolean\" && propData.type !== Boolean) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tconsole.error(`[UI5-FWK] boolean value for property [${name}] of component [${tag}] is missing \"{ type: Boolean }\" in its property decorator. Attribute conversion will treat it as a string. If this is intended, pass the value converted to string, otherwise add the type to the property decorator`);\n\t\t\t}\n\t\t\tif (typeof newValue === \"number\" && propData.type !== Number) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tconsole.error(`[UI5-FWK] numeric value for property [${name}] of component [${tag}] is missing \"{ type: Number }\" in its property decorator. Attribute conversion will treat it as a string. If this is intended, pass the value converted to string, otherwise add the type to the property decorator`);\n\t\t\t}\n\t\t\tif (typeof newValue === \"string\" && propData.type && propData.type !== String) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tconsole.error(`[UI5-FWK] string value for property [${name}] of component [${tag}] which has a non-string type [${propData.type}] in its property decorator. Attribute conversion will stop and keep the string value in the property.`);\n\t\t\t}\n\t\t}\n\n\t\tconst newAttrValue = converter.toAttribute(newValue, propData.type);\n\t\tthis._doNotSyncAttributes.add(attrName); // skip the attributeChangedCallback call for this attribute\n\t\tif (newAttrValue === null || newAttrValue === undefined) { // null means there must be no attribute for the current value of the property\n\t\t\tthis.removeAttribute(attrName); // remove the attribute safely (will not trigger synchronization to the property value due to the above line)\n\t\t} else {\n\t\t\tthis.setAttribute(attrName, newAttrValue); // setting attributes from properties should not trigger the property setter again\n\t\t}\n\t\tthis._doNotSyncAttributes.delete(attrName); // enable synchronization again for this attribute\n\t}\n\n\t/**\n\t * Returns a singleton event listener for the \"change\" event of a child in a given slot\n\t *\n\t * @param slotName the name of the slot, where the child is\n\t * @private\n\t */\n\t_getChildChangeListener(slotName: string): ChildChangeListener {\n\t\tif (!this._childChangeListeners.has(slotName)) {\n\t\t\tthis._childChangeListeners.set(slotName, this._onChildChange.bind(this, slotName));\n\t\t}\n\t\treturn this._childChangeListeners.get(slotName)!;\n\t}\n\n\t/**\n\t * Returns a singleton slotchange event listener that invalidates the component due to changes in the given slot\n\t *\n\t * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n\t * @private\n\t */\n\t_getSlotChangeListener(slotName: string): SlotChangeListener {\n\t\tif (!this._slotChangeListeners.has(slotName)) {\n\t\t\tthis._slotChangeListeners.set(slotName, this._onSlotChange.bind(this, slotName));\n\t\t}\n\t\treturn this._slotChangeListeners.get(slotName)!;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_attachSlotChange(slot: HTMLSlotElement, slotName: string, invalidateOnChildChange: boolean) {\n\t\tconst slotChangeListener = this._getSlotChangeListener(slotName);\n\t\tslot.addEventListener(\"slotchange\", (e: Event) => {\n\t\t\tslotChangeListener.call(slot, e);\n\n\t\t\tif (invalidateOnChildChange) {\n\t\t\t\t// Detach listeners for UI5 Elements that used to be in this slot\n\t\t\t\tconst previousChildren = this._slotsAssignedNodes.get(slot);\n\t\t\t\tif (previousChildren) {\n\t\t\t\t\tpreviousChildren.forEach(child => {\n\t\t\t\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\t\t\t\tchild.detachInvalidate.call(child, childChangeListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Attach listeners for UI5 Elements that are now in this slot\n\t\t\t\tconst newChildren = getSlottedNodesList([slot]);\n\t\t\t\tthis._slotsAssignedNodes.set(slot, newChildren);\n\t\t\t\tnewChildren.forEach(child => {\n\t\t\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\t\t\tchild.attachInvalidate.call(child, childChangeListener);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_detachSlotChange(child: HTMLSlotElement, slotName: string) {\n\t\tchild.removeEventListener(\"slotchange\", this._getSlotChangeListener(slotName));\n\t}\n\n\t/**\n\t * Whenever a slot element is slotted inside a UI5 Web Component, its slotchange event invalidates the component\n\t * Note: this \"slotchange\" listener is for slots that are children of the component (in the light dom, as opposed to slots rendered by the component in the shadow root)\n\t *\n\t * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n\t * @private\n\t */\n\t_onSlotChange(slotName: string) {\n\t\t_invalidate.call(this, {\n\t\t\ttype: \"slot\",\n\t\t\tname: slotName,\n\t\t\treason: \"slotchange\",\n\t\t});\n\t}\n\n\t/**\n\t * A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)\n\t *\n\t * @param  changeInfo An object with information about the change that caused invalidation.\n\t * The object can have the following properties:\n\t *  - type: (property|slot) tells what caused the invalidation\n\t *   1) property: a property value was changed either directly or as a result of changing the corresponding attribute\n\t *   2) slot: a slotted node(nodes) changed in one of several ways (see \"reason\")\n\t *\n\t *  - name: the name of the property or slot that caused the invalidation\n\t *\n\t *  - reason: (children|textcontent|childchange|slotchange) relevant only for type=\"slot\" only and tells exactly what changed in the slot\n\t *   1) children: immediate children (HTML elements or text nodes) were added, removed or reordered in the slot\n\t *   2) textcontent: text nodes in the slot changed value (or nested text nodes were added or changed value). Can only trigger for slots of \"type: Node\"\n\t *   3) slotchange: a slot element, slotted inside that slot had its \"slotchange\" event listener called. This practically means that transitively slotted children changed.\n\t *\t  Can only trigger if the child of a slot is a slot element itself.\n\t *   4) childchange: indicates that a UI5Element child in that slot was invalidated and in turn invalidated the component.\n\t *\t  Can only trigger for slots with \"invalidateOnChildChange\" metadata descriptor\n\t *\n\t *  - newValue: the new value of the property (for type=\"property\" only)\n\t *\n\t *  - oldValue: the old value of the property (for type=\"property\" only)\n\t *\n\t *  - child the child that was changed (for type=\"slot\" and reason=\"childchange\" only)\n\t *\n\t * @public\n\t */\n\tonInvalidation(changeInfo: ChangeInfo): void {} // eslint-disable-line\n\n\tupdateAttributes() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst props = ctor.getMetadata().getProperties();\n\t\tfor (const [prop, propData] of Object.entries(props)) { // eslint-disable-line\n\t\t\tthis._updateAttribute(prop, (this as unknown as Record<string, PropertyValue>)[prop]);\n\t\t}\n\t}\n\n\t/**\n\t * Do not call this method directly, only intended to be called by js\n\t * @protected\n\t */\n\t_render() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst hasIndividualSlots = ctor.getMetadata().hasIndividualSlots();\n\n\t\t// restore properties that were initialized before `define` by calling the setter\n\t\tif (this.initializedProperties.size > 0) {\n\t\t\tArray.from(this.initializedProperties.entries()).forEach(([prop, value]) => {\n\t\t\t\tdelete (this as Record<string, unknown>)[prop];\n\t\t\t\t(this as Record<string, unknown>)[prop] = value;\n\t\t\t});\n\t\t\tthis.initializedProperties.clear();\n\t\t}\n\t\t// suppress invalidation to prevent state changes scheduling another rendering\n\t\tthis._suppressInvalidation = true;\n\n\t\ttry\t{\n\t\t\tthis.onBeforeRendering();\n\n\t\t\tif (!this._rendered) {\n\t\t\t\t// first time rendering, previous setters might have been initializers from the constructor - update attributes here\n\t\t\t\tthis.updateAttributes();\n\t\t\t}\n\n\t\t\t// Intended for framework usage only. Currently ItemNavigation updates tab indexes after the component has updated its state but before the template is rendered\n\t\t\tthis._componentStateFinalizedEventProvider.fireEvent(\"componentStateFinalized\");\n\t\t} finally {\n\t\t\t// always resume normal invalidation handling\n\t\t\tthis._suppressInvalidation = false;\n\t\t}\n\n\t\t// Update the shadow root with the render result\n\t\t/*\n\t\tif (this._changedState.length) {\n\t\t\tlet element = this.localName;\n\t\t\tif (this.id) {\n\t\t\t\telement = `${element}#${this.id}`;\n\t\t\t}\n\t\t\tconsole.log(\"Re-rendering:\", element, this._changedState.map(x => { // eslint-disable-line\n\t\t\t\tlet res = `${x.type}`;\n\t\t\t\tif (x.reason) {\n\t\t\t\t\tres = `${res}(${x.reason})`;\n\t\t\t\t}\n\t\t\t\tres = `${res}: ${x.name}`;\n\t\t\t\tif (x.type === \"property\") {\n\t\t\t\t\tres = `${res} ${JSON.stringify(x.oldValue)} => ${JSON.stringify(x.newValue)}`;\n\t\t\t\t}\n\n\t\t\t\treturn res;\n\t\t\t}));\n\t\t}\n\t\t*/\n\t\tthis._changedState = [];\n\n\t\t// Update shadow root\n\t\tif (ctor._needsShadowDOM()) {\n\t\t\tupdateShadowRoot(this);\n\t\t}\n\t\tthis._rendered = true;\n\n\t\t// Safari requires that children get the slot attribute only after the slot tags have been rendered in the shadow DOM\n\t\tif (hasIndividualSlots) {\n\t\t\tthis._assignIndividualSlotsToChildren();\n\t\t}\n\n\t\t// Call the onAfterRendering hook\n\t\tthis.onAfterRendering();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_assignIndividualSlotsToChildren() {\n\t\tconst domChildren = Array.from(this.children);\n\n\t\tdomChildren.forEach((child: Record<string, any>) => {\n\t\t\tif (child._individualSlot) {\n\t\t\t\tchild.setAttribute(\"slot\", child._individualSlot);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_waitForDomRef() {\n\t\treturn this._domRefReadyPromise;\n\t}\n\n\t/**\n\t * Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template\n\t * *Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option\n\t * Use this method instead of \"this.shadowRoot\" to read the Shadow DOM, if ever necessary\n\t *\n\t * @public\n\t */\n\tgetDomRef(): HTMLElement | undefined {\n\t\t// If a component set _getRealDomRef to its children, use the return value of this function\n\t\tif (typeof this._getRealDomRef === \"function\") {\n\t\t\treturn this._getRealDomRef();\n\t\t}\n\n\t\tif (!this.shadowRoot || this.shadowRoot.children.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.shadowRoot.children[0] as HTMLElement;\n\t}\n\n\t/**\n\t * Returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n\t * This is the element that will receive the focus by default.\n\t * @public\n\t */\n\tgetFocusDomRef(): HTMLElement | undefined {\n\t\tconst domRef = this.getDomRef();\n\t\tif (domRef) {\n\t\t\tconst focusRef = domRef.querySelector(\"[data-sap-focus-ref]\") as HTMLElement;\n\t\t\treturn focusRef || domRef;\n\t\t}\n\t}\n\n\t/**\n\t * Waits for dom ref and then returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n\t * This is the element that will receive the focus by default.\n\t * @public\n\t */\n\tasync getFocusDomRefAsync(): Promise<HTMLElement | undefined> {\n\t\tawait this._waitForDomRef();\n\t\treturn this.getFocusDomRef();\n\t}\n\n\t/**\n\t * Set the focus to the element, returned by \"getFocusDomRef()\" (marked by \"data-sap-focus-ref\")\n\t * @param focusOptions additional options for the focus\n\t * @public\n\t */\n\tasync focus(focusOptions?: FocusOptions): Promise<void> {\n\t\tawait this._waitForDomRef();\n\n\t\tconst focusDomRef = this.getFocusDomRef();\n\t\tif (focusDomRef === this) {\n\t\t\tHTMLElement.prototype.focus.call(this, focusOptions);\n\t\t} else if (focusDomRef && typeof focusDomRef.focus === \"function\") {\n\t\t\tfocusDomRef.focus(focusOptions);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @public\n\t * @param name - name of the event\n\t * @param data - additional data for the event\n\t * @param cancelable - true, if the user can call preventDefault on the event object\n\t * @param bubbles - true, if the event bubbles\n\t * @returns false, if the event was cancelled (preventDefault called), true otherwise\n\t * @deprecated use fireDecoratorEvent instead\n\t */\n\tfireEvent<T>(name: string, data?: T, cancelable = false, bubbles = true): boolean {\n\t\tconst eventResult = this._fireEvent(name, data, cancelable, bubbles);\n\t\tconst pascalCaseEventName = kebabToPascalCase(name);\n\n\t\t// pascal events are more convinient for native react usage\n\t\t// live-change:\n\t\t//\t Before: onlive-change\n\t\t//\t After: onLiveChange\n\t\tif (pascalCaseEventName !== name) {\n\t\t\treturn eventResult && this._fireEvent(pascalCaseEventName, data, cancelable, bubbles);\n\t\t}\n\n\t\treturn eventResult;\n\t}\n\n\t/**\n\t * Fires a custom event, configured via the \"event\" decorator.\n\t * @public\n\t * @param name - name of the event\n\t * @param data - additional data for the event\n\t * @returns false, if the event was cancelled (preventDefault called), true otherwise\n\t */\n\tfireDecoratorEvent<N extends keyof this[\"eventDetails\"]>(name: N, data?: this[\"eventDetails\"][N] | undefined): boolean {\n\t\tconst eventData = this.getEventData(name as string);\n\t\tconst cancellable = eventData ? eventData.cancelable : false;\n\t\tconst bubbles = eventData ? eventData.bubbles : false;\n\n\t\tconst eventResult = this._fireEvent(name as string, data, cancellable, bubbles);\n\t\tconst pascalCaseEventName = kebabToPascalCase(name as string);\n\n\t\t// pascal events are more convinient for native react usage\n\t\t// live-change:\n\t\t//\t Before: onlive-change\n\t\t//\t After: onLiveChange\n\t\tif (pascalCaseEventName !== name) {\n\t\t\treturn eventResult && this._fireEvent(pascalCaseEventName, data, cancellable, bubbles);\n\t\t}\n\n\t\treturn eventResult;\n\t}\n\n\t_fireEvent<T>(name: string, data?: T, cancelable = false, bubbles = true) {\n\t\tconst noConflictEvent = new CustomEvent<T>(`ui5-${name}`, {\n\t\t\tdetail: data,\n\t\t\tcomposed: false,\n\t\t\tbubbles,\n\t\t\tcancelable,\n\t\t});\n\n\t\t// This will be false if the no-conflict event is prevented\n\t\tconst noConflictEventResult = this.dispatchEvent(noConflictEvent);\n\n\t\tif (skipOriginalEvent(name)) {\n\t\t\treturn noConflictEventResult;\n\t\t}\n\n\t\tconst normalEvent = new CustomEvent<T>(name, {\n\t\t\tdetail: data,\n\t\t\tcomposed: false,\n\t\t\tbubbles,\n\t\t\tcancelable,\n\t\t});\n\n\t\t// This will be false if the normal event is prevented\n\t\tconst normalEventResult = this.dispatchEvent(normalEvent);\n\n\t\t// Return false if any of the two events was prevented (its result was false).\n\t\treturn normalEventResult && noConflictEventResult;\n\t}\n\n\tgetEventData(name: string) {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst eventMap = ctor.getMetadata().getEvents();\n\t\treturn eventMap[name];\n\t}\n\n\t/**\n\t * Returns the actual children, associated with a slot.\n\t * Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.\n\t * @public\n\t */\n\tgetSlottedNodes<T = Node>(slotName: string): Array<T> {\n\t\treturn getSlottedNodesList((this as unknown as Record<string, Array<SlotValue>>)[slotName]) as Array<T>;\n\t}\n\n\t/**\n\t * Attach a callback that will be executed whenever the component's state is finalized\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tattachComponentStateFinalized(callback: () => void): void {\n\t\tthis._componentStateFinalizedEventProvider.attachEvent(\"componentStateFinalized\", callback);\n\t}\n\n\t/**\n\t * Detach the callback that is executed whenever the component's state is finalized\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tdetachComponentStateFinalized(callback: () => void): void {\n\t\tthis._componentStateFinalizedEventProvider.detachEvent(\"componentStateFinalized\", callback);\n\t}\n\n\t/**\n\t * Determines whether the component should be rendered in RTL mode or not.\n\t * Returns: \"rtl\", \"ltr\" or undefined\n\t *\n\t * @public\n\t * @default undefined\n\t */\n\tget effectiveDir(): string | undefined {\n\t\tmarkAsRtlAware(this.constructor as typeof UI5Element); // if a UI5 Element calls this method, it's considered to be rtl-aware\n\t\treturn getEffectiveDir(this);\n\t}\n\n\t/**\n\t * Used to duck-type UI5 elements without using instanceof\n\t * @public\n\t * @default true\n\t */\n\tget isUI5Element(): boolean {\n\t\treturn true;\n\t}\n\n\tget isUI5AbstractElement(): boolean {\n\t\treturn !(this.constructor as typeof UI5Element)._needsShadowDOM();\n\t}\n\n\tget classes(): ClassMap {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Returns the component accessibility info.\n\t * @private\n\t */\n\tget accessibilityInfo(): AccessibilityInfo {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Do not override this method in derivatives of UI5Element, use metadata properties instead\n\t * @private\n\t */\n\tstatic get observedAttributes() {\n\t\treturn this.getMetadata().getAttributesList();\n\t}\n\n\t/**\n\t * Returns all tags, used inside component's template subject to scoping.\n\t * returns {Array[]} // TODO add @\n\t * @private\n\t */\n\tstatic get tagsToScope(): Array<string> {\n\t\tconst componentTag = this.getMetadata().getPureTag();\n\t\tconst tagsToScope = this.getUniqueDependencies().map((dep: typeof UI5Element) => dep.getMetadata().getPureTag()).filter(shouldScopeCustomElement);\n\n\t\tif (shouldScopeCustomElement(componentTag)) {\n\t\t\ttagsToScope.push(componentTag);\n\t\t}\n\n\t\treturn tagsToScope;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic _needsShadowDOM() {\n\t\treturn !!this.template || Object.prototype.hasOwnProperty.call(this.prototype, \"render\");\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic _generateAccessors() {\n\t\tconst proto = this.prototype;\n\t\tconst slotsAreManaged = this.getMetadata().slotsAreManaged();\n\n\t\t// Properties\n\t\tconst properties = this.getMetadata().getProperties();\n\t\tfor (const [prop, propData] of Object.entries(properties)) { // eslint-disable-line\n\t\t\tif (!isValidPropertyName(prop)) {\n\t\t\t\tconsole.warn(`\"${prop}\" is not a valid property name. Use a name that does not collide with DOM APIs`); /* eslint-disable-line */\n\t\t\t}\n\n\t\t\tconst descriptor = getPropertyDescriptor(proto, prop);\n\t\t\t// if the decorator is on a setter, proxy the new setter to it\n\t\t\tlet origSet: (v: any) => void;\n\t\t\tif (descriptor?.set) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\torigSet = descriptor.set;\n\t\t\t}\n\t\t\t// if the decorator is on a setter, there will be a corresponding getter - proxy the new getter to it\n\t\t\tlet origGet: () => PropertyValue;\n\t\t\tif (descriptor?.get) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\torigGet = descriptor.get;\n\t\t\t}\n\n\t\t\tObject.defineProperty(proto, prop, {\n\t\t\t\tget(this: UI5Element) {\n\t\t\t\t\t// proxy the getter to the original accessor if there was one\n\t\t\t\t\tif (origGet) {\n\t\t\t\t\t\treturn origGet.call(this);\n\t\t\t\t\t}\n\t\t\t\t\treturn this._state[prop];\n\t\t\t\t},\n\n\t\t\t\tset(this: UI5Element, value: PropertyValue) {\n\t\t\t\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\t\t\t\tconst oldState = origGet ? origGet.call(this) : this._state[prop];\n\n\t\t\t\t\tconst isDifferent = oldState !== value;\n\t\t\t\t\tif (isDifferent) {\n\t\t\t\t\t\t// if the decorator is on a setter, use it for storage\n\t\t\t\t\t\tif (origSet) {\n\t\t\t\t\t\t\torigSet.call(this, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._state[prop] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_invalidate.call(this, {\n\t\t\t\t\t\t\ttype: \"property\",\n\t\t\t\t\t\t\tname: prop,\n\t\t\t\t\t\t\tnewValue: value,\n\t\t\t\t\t\t\toldValue: oldState,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (this._rendered) {\n\t\t\t\t\t\t\t// the component is already rendered, indicating it is not the constructor -\n\t\t\t\t\t\t\t// therefore the attribute can be set synchronously.\n\n\t\t\t\t\t\t\t// get the effective value of the property,\n\t\t\t\t\t\t\t// as it might differ from the provided value\n\t\t\t\t\t\t\tconst newValue = origGet ? origGet.call(this) : this._state[prop];\n\n\t\t\t\t\t\t\tthis._updateAttribute(prop, newValue);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ctor.getMetadata().isFormAssociated()) {\n\t\t\t\t\t\t\tsetFormValue(this as unknown as IFormInputElement);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// Slots\n\t\tif (slotsAreManaged) {\n\t\t\tconst slots = this.getMetadata().getSlots();\n\t\t\tfor (const [slotName, slotData] of Object.entries(slots)) { // eslint-disable-line\n\t\t\t\tif (!isValidPropertyName(slotName)) {\n\t\t\t\t\tconsole.warn(`\"${slotName}\" is not a valid property name. Use a name that does not collide with DOM APIs`); /* eslint-disable-line */\n\t\t\t\t}\n\n\t\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\t\tconst propertyDescriptor: PropertyDescriptor = {\n\t\t\t\t\tget(this: UI5Element) {\n\t\t\t\t\t\tif (this._state[propertyName] !== undefined) {\n\t\t\t\t\t\t\treturn this._state[propertyName];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t},\n\t\t\t\t\tset() {\n\t\t\t\t\t\tthrow new Error(\"Cannot set slot content directly, use the DOM APIs (appendChild, removeChild, etc...)\");\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tObject.defineProperty(proto, propertyName, propertyDescriptor);\n\t\t\t\tif (propertyName !== kebabToCamelCase(propertyName)) {\n\t\t\t\t\tObject.defineProperty(proto, kebabToCamelCase(propertyName), propertyDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the metadata object for this UI5 Web Component Class\n\t * @protected\n\t */\n\tstatic metadata: Metadata = {};\n\n\t/**\n\t * Returns the CSS for this UI5 Web Component Class\n\t * @protected\n\t */\n\tstatic styles: ComponentStylesData = \"\";\n\n\t/**\n\t * Returns an array with the dependencies for this UI5 Web Component, which could be:\n\t *  - composed components (used in its shadow root)\n\t *  - slotted components that the component may need to communicate with\n\t *\n\t * @deprecated no longer necessary for jsxRenderer-enabled components\n\t * @protected\n\t */\n\tstatic get dependencies(): Array<typeof UI5Element> {\n\t\treturn [];\n\t}\n\n\tstatic cacheUniqueDependencies(this: typeof UI5Element): void {\n\t\tconst filtered = this.dependencies.filter((dep, index, deps) => deps.indexOf(dep) === index);\n\t\tuniqueDependenciesCache.set(this, filtered);\n\t}\n\n\t/**\n\t * Returns a list of the unique dependencies for this UI5 Web Component\n\t *\n\t * @public\n\t */\n\tstatic getUniqueDependencies(this: typeof UI5Element): Array<typeof UI5Element> {\n\t\tif (!uniqueDependenciesCache.has(this)) {\n\t\t\tthis.cacheUniqueDependencies();\n\t\t}\n\n\t\treturn uniqueDependenciesCache.get(this) || [];\n\t}\n\n\t/**\n\t * Hook that will be called upon custom element definition\n\t *\n\t * @protected\n\t * @deprecated use the \"i18n\" decorator for fetching message bundles and the \"cldr\" option in the \"customElements\" decorator for fetching CLDR\n\t */\n\tstatic async onDefine(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tstatic fetchI18nBundles() {\n\t\treturn Promise.all(Object.entries(this.getMetadata().getI18n()).map(pair => {\n\t\t\tconst { bundleName } = pair[1];\n\t\t\treturn getI18nBundle(bundleName);\n\t\t}));\n\t}\n\n\tstatic fetchCLDR() {\n\t\tif (this.getMetadata().needsCLDR()) {\n\t\t\treturn fetchCldr(getLocale().getLanguage(), getLocale().getRegion(), getLocale().getScript());\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n\n\tstatic asyncFinished: boolean;\n\tstatic definePromise: Promise<void> | undefined;\n\tstatic i18nBundleStorage: Record<string, I18nBundle> = {};\n\n\tstatic get i18nBundles(): Record<string, I18nBundle> {\n\t\treturn this.i18nBundleStorage;\n\t}\n\n\t/**\n\t * Registers a UI5 Web Component in the browser window object\n\t * @public\n\t */\n\tstatic define(): typeof UI5Element {\n\t\tconst defineSequence = async () => {\n\t\t\tawait boot(); // boot must finish first, because it initializes configuration\n\t\t\tconst result = await Promise.all([\n\t\t\t\tthis.fetchI18nBundles(), // uses configuration\n\t\t\t\tthis.fetchCLDR(),\n\t\t\t\tthis.onDefine(),\n\t\t\t]);\n\t\t\tconst [i18nBundles] = result;\n\t\t\tObject.entries(this.getMetadata().getI18n()).forEach((pair, index) => {\n\t\t\t\tconst bundleName = pair[1].bundleName;\n\t\t\t\tthis.i18nBundleStorage[bundleName] = i18nBundles[index];\n\t\t\t});\n\t\t\tthis.asyncFinished = true;\n\t\t};\n\t\tthis.definePromise = defineSequence();\n\n\t\tconst tag = this.getMetadata().getTag();\n\n\t\tconst definedLocally = isTagRegistered(tag);\n\t\tconst definedGlobally = customElements.get(tag);\n\n\t\tif (definedGlobally && !definedLocally) {\n\t\t\trecordTagRegistrationFailure(tag);\n\t\t} else if (!definedGlobally) {\n\t\t\tthis._generateAccessors();\n\t\t\tregisterTag(tag);\n\t\t\tcustomElements.define(tag, this as unknown as CustomElementConstructor);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an instance of UI5ElementMetadata.js representing this UI5 Web Component's full metadata (its and its parents')\n\t * Note: not to be confused with the \"get metadata()\" method, which returns an object for this class's metadata only\n\t * @public\n\t */\n\tstatic getMetadata(): UI5ElementMetadata {\n\t\tif (this.hasOwnProperty(\"_metadata\")) { // eslint-disable-line\n\t\t\treturn this._metadata;\n\t\t}\n\n\t\tconst metadataObjects = [this.metadata];\n\t\tlet klass = this; // eslint-disable-line\n\t\twhile (klass !== UI5Element) {\n\t\t\tklass = Object.getPrototypeOf(klass);\n\t\t\tmetadataObjects.unshift(klass.metadata);\n\t\t}\n\t\tconst mergedMetadata = merge({}, ...metadataObjects) as Metadata;\n\n\t\tthis._metadata = new UI5ElementMetadata(mergedMetadata);\n\t\treturn this._metadata;\n\t}\n\n\tget validity() { return this._internals.validity; }\n\tget validationMessage() { return this._internals.validationMessage; }\n\tcheckValidity() { return this._internals.checkValidity(); }\n\treportValidity() { return this._internals.reportValidity(); }\n}\n\n/**\n * Always use duck-typing to cover all runtimes on the page.\n */\nconst instanceOfUI5Element = (object: any): object is UI5Element => {\n\treturn \"isUI5Element\" in object;\n};\n\nexport default UI5Element;\nexport {\n\tinstanceOfUI5Element,\n};\nexport type {\n\tChangeInfo,\n\tInvalidationInfo,\n\tRenderer,\n\tSlottedChild,\n};\n"],
  "mappings": "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",
  "names": ["merge", "boot", "UI5ElementMetadata", "EventProvider", "updateShadowRoot", "shouldIgnoreCustomElement", "renderDeferred", "renderImmediately", "cancelRender", "registerTag", "isTagRegistered", "recordTagRegistrationFailure", "observeDOMNode", "unobserveDOMNode", "skipOriginalEvent", "getEffectiveDir", "kebabToCamelCase", "camelToKebabCase", "kebabToPascalCase", "isValidPropertyName", "getSlotName", "getSlottedNodesList", "arraysAreEqual", "markAsRtlAware", "executeTemplate", "shouldScopeCustomElement", "updateFormValue", "setFormValue", "getI18nBundle", "fetchCldr", "getLocale", "autoId", "elementTimeouts", "uniqueDependenciesCache", "defaultConverter", "value", "type", "_invalidate", "changeInfo", "getPropertyDescriptor", "proto", "name", "descriptor", "UI5Element", "ctor", "deferredResolve", "resolve", "propertyName", "defaultOptions", "e", "template", "slotsAreManaged", "metadata", "canSlotText", "mutationObserverOptions", "slotsMap", "domChildren", "slotsCachedContentMap", "propertyNameToSlotMap", "slotName", "slotData", "autoIncrementMap", "slottedChildrenMap", "allChildrenUpgraded", "child", "idx", "validValues", "nextIndex", "localName", "whenDefinedPromise", "timeoutPromise", "instanceOfUI5Element", "childChangeListener", "children", "a", "b", "_", "invalidated", "callback", "childChangeInfo", "oldValue", "newValue", "newPropertyValue", "properties", "realName", "nameInCamelCase", "propData", "attrName", "newAttrValue", "slot", "invalidateOnChildChange", "slotChangeListener", "previousChildren", "newChildren", "props", "prop", "hasIndividualSlots", "domRef", "focusOptions", "focusDomRef", "data", "cancelable", "bubbles", "eventResult", "pascalCaseEventName", "eventData", "cancellable", "noConflictEvent", "noConflictEventResult", "normalEvent", "componentTag", "tagsToScope", "dep", "origSet", "origGet", "oldState", "slots", "propertyDescriptor", "filtered", "index", "deps", "pair", "bundleName", "defineSequence", "result", "i18nBundles", "tag", "definedLocally", "definedGlobally", "metadataObjects", "klass", "mergedMetadata", "object"]
}
