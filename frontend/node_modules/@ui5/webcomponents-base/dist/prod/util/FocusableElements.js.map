{
  "version": 3,
  "sources": ["../../../src/util/FocusableElements.ts"],
  "sourcesContent": ["import isElementHidden from \"./isElementHidden.js\";\nimport isElementClickable from \"./isElementClickable.js\";\nimport { instanceOfUI5Element } from \"../UI5Element.js\";\nimport { isSafari } from \"../Device.js\";\n\ntype FocusableElementPromise = Promise<HTMLElement | null>;\n\nconst isFocusTrap = (el: HTMLElement) => {\n\treturn el.hasAttribute(\"data-ui5-focus-trap\");\n};\n\nconst isScrollable = (el: HTMLElement) => {\n\tconst computedStyle = getComputedStyle(el);\n\n\treturn (el.scrollHeight > el.clientHeight && [\"scroll\", \"auto\"].indexOf(computedStyle.overflowY) >= 0)\n\t\t|| (el.scrollWidth > el.clientWidth && [\"scroll\", \"auto\"].indexOf(computedStyle.overflowX) >= 0);\n};\n\nconst getFirstFocusableElement = async (container: HTMLElement, startFromContainer?: boolean): FocusableElementPromise => {\n\tif (!container || isElementHidden(container)) {\n\t\treturn null;\n\t}\n\n\treturn findFocusableElement(container, true, startFromContainer);\n};\n\nconst getLastFocusableElement = async (container: HTMLElement, startFromContainer?: boolean): FocusableElementPromise => {\n\tif (!container || isElementHidden(container)) {\n\t\treturn null;\n\t}\n\n\treturn findFocusableElement(container, false, startFromContainer);\n};\n\nconst isElemFocusable = (el: HTMLElement) => {\n\treturn el.hasAttribute(\"data-ui5-focus-redirect\") || !isElementHidden(el);\n};\n\nconst isUI5ElementWithNegativeTabIndex = (el: HTMLElement) => {\n\tif (instanceOfUI5Element(el)) {\n\t\tconst tabIndex = el.getAttribute(\"tabindex\");\n\t\tif (tabIndex !== null && parseInt(tabIndex) < 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nconst findFocusableElement = async (container: HTMLElement, forward: boolean, startFromContainer?: boolean): FocusableElementPromise => {\n\tlet child: HTMLElement | undefined;\n\tlet assignedElements;\n\tlet currentIndex = -1;\n\n\tif (container.shadowRoot) {\n\t\tchild = forward ? container.shadowRoot.firstChild as HTMLElement : container.shadowRoot.lastChild as HTMLElement;\n\t} else if (container instanceof HTMLSlotElement && container.assignedNodes()) {\n\t\tassignedElements = container.assignedNodes();\n\t\tcurrentIndex = forward ? 0 : assignedElements.length - 1;\n\t\tchild = assignedElements[currentIndex] as HTMLElement;\n\t} else if (startFromContainer) {\n\t\tchild = container;\n\t} else {\n\t\tchild = forward ? container.firstElementChild as HTMLElement : container.lastElementChild as HTMLElement;\n\t}\n\n\tlet focusableDescendant;\n\n\t/* eslint-disable no-await-in-loop */\n\n\twhile (child) {\n\t\tconst originalChild: HTMLElement | undefined = child;\n\n\t\tif (!isElementHidden(originalChild) && !isUI5ElementWithNegativeTabIndex(originalChild)) {\n\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\t// getDomRef is used because some components mark their focusable ref in an inner\n\t\t\t\t// html but there might also be focusable targets outside of it\n\t\t\t\t// as an example - TreeItemBase\n\t\t\t\t// div - root of the component returned by getDomRef()\n\t\t\t\t// \tli.ui5-li-tree - returned by getFocusDomRef() and may not be focusable (ItemNavigation manages tabindex)\n\t\t\t\t// \tul.subtree - may still contain focusable targets (sub nodes of the tree item)\n\t\t\t\tawait child._waitForDomRef();\n\t\t\t\tchild = child.getDomRef();\n\t\t\t}\n\n\t\t\tif (!child || isElementHidden(child)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (child.nodeType === 1 && isElemFocusable(child) && !isFocusTrap(child)) {\n\t\t\t\tif (isElementClickable(child)) {\n\t\t\t\t\treturn (child && typeof child.focus === \"function\") ? child : null;\n\t\t\t\t}\n\n\t\t\t\tfocusableDescendant = await findFocusableElement(child, forward);\n\n\t\t\t\t// check if it is a keyboard focusable scroll container\n\t\t\t\tif (!isSafari() && !focusableDescendant && isScrollable(child)) {\n\t\t\t\t\treturn (child && typeof child.focus === \"function\") ? child : null;\n\t\t\t\t}\n\n\t\t\t\tif (focusableDescendant) {\n\t\t\t\t\treturn (focusableDescendant && typeof focusableDescendant.focus === \"function\") ? focusableDescendant : null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchild = forward ? originalChild.nextSibling as HTMLElement : originalChild.previousSibling as HTMLElement;\n\n\t\t// If the child element is not part of the currently assigned element,\n\t\t// we have to check the next/previous element assigned to the slot or continue with the next/previous sibling of the slot,\n\t\t// otherwise, the nextSibling/previousSibling is the next element inside the light DOM\n\t\tif (assignedElements && !assignedElements[currentIndex].contains(child)) {\n\t\t\tcurrentIndex = forward ? currentIndex + 1 : currentIndex - 1;\n\n\t\t\tchild = assignedElements[currentIndex] as HTMLElement;\n\t\t}\n\t}\n\n\t/* eslint-enable no-await-in-loop */\n\n\treturn null;\n};\n\nexport {\n\tgetFirstFocusableElement,\n\tgetLastFocusableElement,\n};\n"],
  "mappings": "aAAA,OAAOA,MAAqB,uBAC5B,OAAOC,MAAwB,0BAC/B,OAAS,wBAAAC,MAA4B,mBACrC,OAAS,YAAAC,MAAgB,eAIzB,MAAMC,EAAeC,GACbA,EAAG,aAAa,qBAAqB,EAGvCC,EAAgBD,GAAoB,CACzC,MAAME,EAAgB,iBAAiBF,CAAE,EAEzC,OAAQA,EAAG,aAAeA,EAAG,cAAgB,CAAC,SAAU,MAAM,EAAE,QAAQE,EAAc,SAAS,GAAK,GAC/FF,EAAG,YAAcA,EAAG,aAAe,CAAC,SAAU,MAAM,EAAE,QAAQE,EAAc,SAAS,GAAK,CAChG,EAEMC,EAA2B,MAAOC,EAAwBC,IAC3D,CAACD,GAAaT,EAAgBS,CAAS,EACnC,KAGDE,EAAqBF,EAAW,GAAMC,CAAkB,EAG1DE,EAA0B,MAAOH,EAAwBC,IAC1D,CAACD,GAAaT,EAAgBS,CAAS,EACnC,KAGDE,EAAqBF,EAAW,GAAOC,CAAkB,EAG3DG,EAAmBR,GACjBA,EAAG,aAAa,yBAAyB,GAAK,CAACL,EAAgBK,CAAE,EAGnES,EAAoCT,GAAoB,CAC7D,GAAIH,EAAqBG,CAAE,EAAG,CAC7B,MAAMU,EAAWV,EAAG,aAAa,UAAU,EAC3C,GAAIU,IAAa,MAAQ,SAASA,CAAQ,EAAI,EAC7C,MAAO,EAET,CAEA,MAAO,EACR,EAEMJ,EAAuB,MAAOF,EAAwBO,EAAkBN,IAA0D,CACvI,IAAIO,EACAC,EACAC,EAAe,GAEfV,EAAU,WACbQ,EAAQD,EAAUP,EAAU,WAAW,WAA4BA,EAAU,WAAW,UAC9EA,aAAqB,iBAAmBA,EAAU,cAAc,GAC1ES,EAAmBT,EAAU,cAAc,EAC3CU,EAAeH,EAAU,EAAIE,EAAiB,OAAS,EACvDD,EAAQC,EAAiBC,CAAY,GAC3BT,EACVO,EAAQR,EAERQ,EAAQD,EAAUP,EAAU,kBAAmCA,EAAU,iBAG1E,IAAIW,EAIJ,KAAOH,GAAO,CACb,MAAMI,EAAyCJ,EAE/C,GAAI,CAACjB,EAAgBqB,CAAa,GAAK,CAACP,EAAiCO,CAAa,EAAG,CAYxF,GAXInB,EAAqBe,CAAK,IAO7B,MAAMA,EAAM,eAAe,EAC3BA,EAAQA,EAAM,UAAU,GAGrB,CAACA,GAASjB,EAAgBiB,CAAK,EAClC,OAAO,KAGR,GAAIA,EAAM,WAAa,GAAKJ,EAAgBI,CAAK,GAAK,CAACb,EAAYa,CAAK,EAAG,CAQ1E,GAPIhB,EAAmBgB,CAAK,IAI5BG,EAAsB,MAAMT,EAAqBM,EAAOD,CAAO,EAG3D,CAACb,EAAS,GAAK,CAACiB,GAAuBd,EAAaW,CAAK,GAC5D,OAAQA,GAAS,OAAOA,EAAM,OAAU,WAAcA,EAAQ,KAG/D,GAAIG,EACH,OAAQA,GAAuB,OAAOA,EAAoB,OAAU,WAAcA,EAAsB,IAE1G,CACD,CAEAH,EAAQD,EAAUK,EAAc,YAA6BA,EAAc,gBAKvEH,GAAoB,CAACA,EAAiBC,CAAY,EAAE,SAASF,CAAK,IACrEE,EAAeH,EAAUG,EAAe,EAAIA,EAAe,EAE3DF,EAAQC,EAAiBC,CAAY,EAEvC,CAIA,OAAO,IACR,EAEA,OACCX,KAAA,yBACAI,KAAA",
  "names": ["isElementHidden", "isElementClickable", "instanceOfUI5Element", "isSafari", "isFocusTrap", "el", "isScrollable", "computedStyle", "getFirstFocusableElement", "container", "startFromContainer", "findFocusableElement", "getLastFocusableElement", "isElemFocusable", "isUI5ElementWithNegativeTabIndex", "tabIndex", "forward", "child", "assignedElements", "currentIndex", "focusableDescendant", "originalChild"]
}
