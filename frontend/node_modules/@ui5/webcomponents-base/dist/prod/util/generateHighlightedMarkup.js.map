{
  "version": 3,
  "sources": ["../../../src/util/generateHighlightedMarkup.ts"],
  "sourcesContent": ["import escapeRegex from \"./escapeRegex.js\";\n// @ts-ignore\nimport encodeXML from \"../sap/base/security/encodeXML.js\";\n\n// utility to replace all occurances of a string\nfunction replaceAll(text: string, find: string, replace: string | ((substring: string, ...args: any[]) => string), caseInsensitive: boolean) {\n\treturn text.replaceAll(new RegExp(escapeRegex(find), `${caseInsensitive ? \"i\" : \"\"}g`), replace as string);\n}\n\n/**\n * Generate markup for a raw string where a particular text is wrapped with some tag, by default `<b>` (bold) tag.\n * All inputs to this function are considered literal text, and special characters will always be escaped.\n * @param {string} text The text to add highlighting to\n * @param {string} textToHighlight The text which should be highlighted\n * @return {string} the markup HTML which contains all occurrances of the input text surrounded with a `<b>` tag.\n */\nfunction generateHighlightedMarkup(text: string, textToHighlight: string) {\n\tif (!text || !textToHighlight) {\n\t\treturn text;\n\t}\n\t// a token is some string that does not appear in either of the input strings\n\t// repeat the token until it does not appear in the string\n\tconst makeToken = (t: string) => {\n\t\tconst [s, e] = t.split(\"\");\n\t\twhile (text.indexOf(t) >= 0 || textToHighlight.indexOf(t) >= 0) {\n\t\t\tt = `${s}${t}${e}`;\n\t\t}\n\t\treturn t;\n\t};\n\t// It doesn't matter what characters are used as long as all 4 of them are unique\n\t// And also that encodeXML will not change these characters\n\tconst openToken = makeToken(\"12\");\n\tconst closeToken = makeToken(\"34\");\n\t// wrap every occurance of the textToHighlight using the open/close tokens (instead of markup at this point)\n\tlet result = encodeXML(replaceAll(text, textToHighlight, (match: string) => `${openToken}${match}${closeToken}`, true)) as string;\n\t// now replace the open and close tokens with the markup that we expect\n\t[[openToken, \"<b>\"], [closeToken, \"</b>\"]].forEach(([find, replace]) => {\n\t\tresult = replaceAll(result, find, replace, false);\n\t});\n\treturn result;\n}\n\nexport default generateHighlightedMarkup;\n"],
  "mappings": "aAAA,OAAOA,MAAiB,mBAExB,OAAOC,MAAe,oCAGtB,SAASC,EAAWC,EAAcC,EAAcC,EAAmEC,EAA0B,CAC5I,OAAOH,EAAK,WAAW,IAAI,OAAOH,EAAYI,CAAI,EAAG,GAAGE,EAAkB,IAAM,EAAE,GAAG,EAAGD,CAAiB,CAC1G,CASA,SAASE,EAA0BJ,EAAcK,EAAyB,CACzE,GAAI,CAACL,GAAQ,CAACK,EACb,OAAOL,EAIR,MAAMM,EAAaC,GAAc,CAChC,KAAM,CAACC,EAAGC,CAAC,EAAIF,EAAE,MAAM,EAAE,EACzB,KAAOP,EAAK,QAAQO,CAAC,GAAK,GAAKF,EAAgB,QAAQE,CAAC,GAAK,GAC5DA,EAAI,GAAGC,CAAC,GAAGD,CAAC,GAAGE,CAAC,GAEjB,OAAOF,CACR,EAGMG,EAAYJ,EAAU,IAAI,EAC1BK,EAAaL,EAAU,IAAI,EAEjC,IAAIM,EAASd,EAAUC,EAAWC,EAAMK,EAAkBQ,GAAkB,GAAGH,CAAS,GAAGG,CAAK,GAAGF,CAAU,GAAI,EAAI,CAAC,EAEtH,OAAC,CAACD,EAAW,KAAK,EAAG,CAACC,EAAY,MAAM,CAAC,EAAE,QAAQ,CAAC,CAACV,EAAMC,CAAO,IAAM,CACvEU,EAASb,EAAWa,EAAQX,EAAMC,EAAS,EAAK,CACjD,CAAC,EACMU,CACR,CAEA,eAAeR",
  "names": ["escapeRegex", "encodeXML", "replaceAll", "text", "find", "replace", "caseInsensitive", "generateHighlightedMarkup", "textToHighlight", "makeToken", "t", "s", "e", "openToken", "closeToken", "result", "match"]
}
