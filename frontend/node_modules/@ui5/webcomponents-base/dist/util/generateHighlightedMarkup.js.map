{"version":3,"file":"generateHighlightedMarkup.js","sourceRoot":"","sources":["../../src/util/generateHighlightedMarkup.ts"],"names":[],"mappings":"AAAA,OAAO,WAAW,MAAM,kBAAkB,CAAC;AAC3C,aAAa;AACb,OAAO,SAAS,MAAM,mCAAmC,CAAC;AAE1D,gDAAgD;AAChD,SAAS,UAAU,CAAC,IAAY,EAAE,IAAY,EAAE,OAAiE,EAAE,eAAwB;IAC1I,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,OAAiB,CAAC,CAAC;AAC5G,CAAC;AAED;;;;;;GAMG;AACH,SAAS,yBAAyB,CAAC,IAAY,EAAE,eAAuB;IACvE,IAAI,CAAC,IAAI,IAAI,CAAC,eAAe,EAAE;QAC9B,OAAO,IAAI,CAAC;KACZ;IACD,6EAA6E;IAC7E,0DAA0D;IAC1D,MAAM,SAAS,GAAG,CAAC,CAAS,EAAE,EAAE;QAC/B,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC3B,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;YAC/D,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;SACnB;QACD,OAAO,CAAC,CAAC;IACV,CAAC,CAAC;IACF,iFAAiF;IACjF,2DAA2D;IAC3D,MAAM,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;IAClC,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;IACnC,4GAA4G;IAC5G,IAAI,MAAM,GAAG,SAAS,CAAC,UAAU,CAAC,IAAI,EAAE,eAAe,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,GAAG,SAAS,GAAG,KAAK,GAAG,UAAU,EAAE,EAAE,IAAI,CAAC,CAAW,CAAC;IAClI,uEAAuE;IACvE,CAAC,CAAC,SAAS,EAAE,KAAK,CAAC,EAAE,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,EAAE;QACtE,MAAM,GAAG,UAAU,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC;IACH,OAAO,MAAM,CAAC;AACf,CAAC;AAED,eAAe,yBAAyB,CAAC","sourcesContent":["import escapeRegex from \"./escapeRegex.js\";\n// @ts-ignore\nimport encodeXML from \"../sap/base/security/encodeXML.js\";\n\n// utility to replace all occurances of a string\nfunction replaceAll(text: string, find: string, replace: string | ((substring: string, ...args: any[]) => string), caseInsensitive: boolean) {\n\treturn text.replaceAll(new RegExp(escapeRegex(find), `${caseInsensitive ? \"i\" : \"\"}g`), replace as string);\n}\n\n/**\n * Generate markup for a raw string where a particular text is wrapped with some tag, by default `<b>` (bold) tag.\n * All inputs to this function are considered literal text, and special characters will always be escaped.\n * @param {string} text The text to add highlighting to\n * @param {string} textToHighlight The text which should be highlighted\n * @return {string} the markup HTML which contains all occurrances of the input text surrounded with a `<b>` tag.\n */\nfunction generateHighlightedMarkup(text: string, textToHighlight: string) {\n\tif (!text || !textToHighlight) {\n\t\treturn text;\n\t}\n\t// a token is some string that does not appear in either of the input strings\n\t// repeat the token until it does not appear in the string\n\tconst makeToken = (t: string) => {\n\t\tconst [s, e] = t.split(\"\");\n\t\twhile (text.indexOf(t) >= 0 || textToHighlight.indexOf(t) >= 0) {\n\t\t\tt = `${s}${t}${e}`;\n\t\t}\n\t\treturn t;\n\t};\n\t// It doesn't matter what characters are used as long as all 4 of them are unique\n\t// And also that encodeXML will not change these characters\n\tconst openToken = makeToken(\"12\");\n\tconst closeToken = makeToken(\"34\");\n\t// wrap every occurance of the textToHighlight using the open/close tokens (instead of markup at this point)\n\tlet result = encodeXML(replaceAll(text, textToHighlight, (match: string) => `${openToken}${match}${closeToken}`, true)) as string;\n\t// now replace the open and close tokens with the markup that we expect\n\t[[openToken, \"<b>\"], [closeToken, \"</b>\"]].forEach(([find, replace]) => {\n\t\tresult = replaceAll(result, find, replace, false);\n\t});\n\treturn result;\n}\n\nexport default generateHighlightedMarkup;\n"]}